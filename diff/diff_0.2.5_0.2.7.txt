diff --git a/extension/chrome/content/container.js b/extension/chrome/content/container.js
index f4931d2..309f4f6 100644
--- a/extension/chrome/content/container.js
+++ b/extension/chrome/content/container.js
@@ -57,6 +57,9 @@ let FireIEContainer = {};
     if (needPrivateBrowsingWarning())
     {
       container.innerHTML = '<iframe src="PrivateBrowsingWarning.xhtml" width="100%" height="100%" frameborder="no" border="0" marginwidth="0" marginheight="0" scrolling="no" allowtransparency="yes"></iframe>';
+      // Set tab icon to pbw icon
+      Favicon.setIcon(document, "chrome://global/skin/icons/warning-16.png");
+      document.title = Utils.getString("fireie.pbw.title");
     }
     else
     {
@@ -205,7 +208,9 @@ let FireIEContainer = {};
   function onSetStatusText(event)
   {
     let statusbar = E(Utils.statusBarId);
-    let statustext = event.statusText;
+    let statustext = event.getData("statusText");
+    if (typeof(statustext) == "undefined")
+      statustext = "";
     let pretext = "";
     if (statusbar.firstChild)
     {
@@ -240,38 +245,42 @@ let FireIEContainer = {};
       hideStatusBar();
   }
 
+  let mouseScrollBubbleProtect = false;
   function onDOMMouseScroll(event)
   {
-    // constants from Win API
-    const SCROLL_PAGE_DOWN = 32768;
-    const SCROLL_PAGE_UP = -32768;
-    
-    // If it's a plain mouse wheel scroll, set focus on the IE control
-    // in order to let user scroll the content
-    if (event.axis == event.VERTICAL_AXIS
-        && !event.ctrlKey && !event.shiftKey && !event.altKey && !event.metaKey)
-    {
-      // Gecko 15+ supports "buttons" attribute
-      if (typeof(event.buttons) == "undefined" || event.buttons == 0)
+    if (mouseScrollBubbleProtect) return;
+    mouseScrollBubbleProtect = true;
+
+    try {
+      // constants from Win API
+      const SCROLL_PAGE_DOWN = 32768;
+      const SCROLL_PAGE_UP = -32768;
+      
+      // If it's a plain mouse wheel scroll, set focus on the IE control
+      // in order to let user scroll the content
+      if (event.axis == event.VERTICAL_AXIS
+          && !event.ctrlKey && !event.shiftKey && !event.altKey && !event.metaKey)
       {
-        // it's a plain wheel scroll, transfer focus to the control
-        let pluginObject = E(Utils.containerPluginId);
-        if (pluginObject)
+        // Gecko 15+ supports "buttons" attribute
+        if (typeof(event.buttons) == "undefined" || event.buttons == 0)
         {
-          // note we're focusing the plugin object, not the plugin control
-          // the object's focus handler will help us transfer the window focus
-          pluginObject.focus();
-          // forward this scroll result (UP or DOWN) as it's not sent to the control
-          if (event.detail > 0)
+          // it's a plain wheel scroll, transfer focus to the control
+          let pluginObject = E(Utils.containerPluginId);
+          if (pluginObject)
           {
-            event.detail == SCROLL_PAGE_DOWN ? pluginObject.PageDown() : pluginObject.LineDown();
-          }
-          else if (event.detail < 0)
-          {
-            event.detail == SCROLL_PAGE_UP ? pluginObject.PageUp() : pluginObject.LineUp();
+            // note we're focusing the plugin object, not the plugin control
+            // the object's focus handler will help us transfer the window focus
+            pluginObject.focus();
+            // forward this scroll result (UP or DOWN) as it's not sent to the control
+            event.detail > 0 ? pluginObject.ScrollWheelDown() : pluginObject.ScrollWheelUp();
           }
         }
       }
+    } finally {
+      setTimeout(function()
+      {
+        mouseScrollBubbleProtect = false;
+      }, 500);
     }
   }
 
diff --git a/extension/chrome/content/firstRun.js b/extension/chrome/content/firstRun.js
index b8da048..e6823d7 100644
--- a/extension/chrome/content/firstRun.js
+++ b/extension/chrome/content/firstRun.js
@@ -23,9 +23,6 @@ function init()
       break;
     }
   }
-
-  if (RuleStorage.subscriptions.some(function(s) s.url == Prefs.subscriptions_exceptionsurl))
-    E("acceptableAds").hidden = false;
 }
 
 function generateLinkText(element)
diff --git a/extension/chrome/content/overlay.js b/extension/chrome/content/overlay.js
index 127a3a7..a79147f 100644
--- a/extension/chrome/content/overlay.js
+++ b/extension/chrome/content/overlay.js
@@ -29,52 +29,294 @@ var gFireIE = null;
   Cu.import(baseURL.spec + "AppIntegration.jsm", jsm);
   Cu.import(baseURL.spec + "Utils.jsm", jsm);
   Cu.import(baseURL.spec + "GesturePrefObserver.jsm", jsm);
+  Cu.import(baseURL.spec + "HookManager.jsm", jsm);
+  
   let
   {
-    AppIntegration, Utils, GesturePrefObserver
+    AppIntegration, Utils, GesturePrefObserver, HookManager
   } = jsm;
-  AppIntegration.addWindow(window);
-  gFireIE = AppIntegration.getWrapperForWindow(window);
+  
+  let HM = new HookManager(window, "gFireIE._hookManager");
+  let RET = HM.RET;
+  
+  // hook click_to_play, should take place before WindowWrapper installs the utils plugin
+  let clickToPlayHandler = function(event)
+  {
+    let plugin = event.target;
+
+    // We're expecting the target to be a plugin.
+    if (!(plugin instanceof Ci.nsIObjectLoadingContent))
+      return;
+      
+    // used to check whether the plugin is already activated
+    let objLoadingContent = plugin.QueryInterface(Ci.nsIObjectLoadingContent);
+    
+    let mimetype = plugin.getAttribute("type");
+    if (mimetype == "application/fireie")
+    {
+      // check the container page
+      let doc = plugin.ownerDocument;
+      let url = doc.location.href;
+      if (Utils.startsWith(url, Utils.containerUrl))
+      {
+        // ok, play the plugin and let go
+        if (!objLoadingContent.activated)
+        {
+          plugin.playPlugin();
+          gFireIE.updateInterface();
+        }
+        event.stopPropagation();
+        return RET.shouldReturn();
+      }
+      // maybe it's a utils plugin
+      if (doc.location.href == "chrome://browser/content/browser.xul")
+      {
+        // ok, play the utils plugin
+        if (!objLoadingContent.activated)
+        {
+          plugin.playPlugin();
+          gFireIE.updateInterface();
+        }
+        event.stopPropagation();
+        return RET.shouldReturn();
+      }
+      // let gPluginHandler do the rest of the work
+    }
+  };
+  this.window.addEventListener("PluginClickToPlay", clickToPlayHandler, true);
+  // still we have to hook gPluginHandler.handleEvent
+  // in case they start listening on the window object
+  if (typeof(gPluginHandler) == "object" && typeof(gPluginHandler.handleEvent) == "function")
+  {
+    HM.hookCodeHead("gPluginHandler.handleEvent", clickToPlayHandler);
+  }
 
-  function initializeHooks()
+  gFireIE = AppIntegration.addWindow(window);
+  gFireIE._hookManager = HM;
+  
+  function initBasicHooks()
   {
+    // work around with TU's excessive use of source-patching code
+    if (typeof(TU_hookFunc) == "function")
+    {
+      HM.redirectSourcePatchingHook("TU_hookFunc", 0);
+    }
+    if (typeof(Tabmix) != "undefined" && typeof(Tabmix.newCode) == "function")
+    {
+      HM.redirectSPHNameFunc("Tabmix.newCode", 0, 1);
+    }
+  
     //hook properties
-    gFireIE.hookBrowserGetter(gBrowser.mTabContainer.firstChild.linkedBrowser);
-    hookURLBarSetter(gURLBar);
-
-    //hook functions
-    hookCode("PlacesCommandHook.bookmarkPage", "aBrowser.currentURI", "makeURI(gFireIE.Utils.fromContainerUrl($&.spec))"); // Obtain real URL when bookmarking
-    hookCode("PlacesControllerDragHelper.onDrop", "data.linkedBrowser.currentURI", "makeURI(gFireIE.Utils.fromContainerUrl($&.spec))"); // Obtain real URL when bookmarking
-    hookCode("PlacesStarButton.updateState", /(gBrowser|getBrowser\(\))\.currentURI/g, "makeURI(gFireIE.Utils.fromContainerUrl($&.spec))"); // Show bookmark state (the star icon in URL bar) when using IE engine
-    hookCode("StarUI._doShowEditBookmarkPanel", /(gBrowser|getBrowser\(\))\.currentURI/g, "makeURI(gFireIE.Utils.fromContainerUrl($&.spec))"); // Show number of bookmarks in the overlay editing panel when using IE engine
-    hookCode("gBrowser.addTab", "return t;", "gFireIE.hookBrowserGetter(t.linkedBrowser); $&");
-    hookCode("gBrowser.setTabTitle", "if (browser.currentURI.spec) {", "$& if (browser.currentURI.spec.indexOf(gFireIE.Utils.containerUrl) == 0) return;"); // Cancel setTabTitle when using IE engine
-    hookCode("getShortcutOrURI", /return (\S+);/g, "return gFireIE.getHandledURL($1);"); // Visit the new URL
-    //hook Interface Commands
-    hookCode("BrowserBack", /{/, "$& if(gFireIE.goDoCommand('Back')) return;");
-    hookCode("BrowserForward", /{/, "$& if(gFireIE.goDoCommand('Forward')) return;");
-    hookCode("BrowserStop", /{/, "$& if(gFireIE.goDoCommand('Stop')) return;");
-    hookCode("BrowserReload", /{/, "$& if(gFireIE.goDoCommand('Refresh')) return;");
-    hookCode("BrowserReloadSkipCache", /{/, "$& if(gFireIE.goDoCommand('Refresh')) return;");
-
-    hookCode("saveDocument", /{/, "$& if(gFireIE.goDoCommand('SaveAs')) return;");
-    hookCode("MailIntegration.sendMessage", /{/, "$& let pluginObject = gFireIE.getContainerPlugin(); if(pluginObject){ arguments[0]=pluginObject.URL; arguments[1]=pluginObject.Title; }"); // @todo Send mail?
-    hookCode("PrintUtils.print", /{/, "$& if(gFireIE.goDoCommand('Print')) return;");
-    hookCode("PrintUtils.showPageSetup", /{/, "$& if(gFireIE.goDoCommand('PrintSetup')) return;");
-    hookCode("PrintUtils.printPreview", /{/, "$& if(gFireIE.goDoCommand('PrintPreview')) return;");
-
-    hookCode("goDoCommand", /{/, "$& if(gFireIE.goDoCommand(arguments[0])) return;"); // cmd_cut, cmd_copy, cmd_paste, cmd_selectAll
-    let displaySecurityInfoCode = "if((typeof(event)=='undefined'||(event.type=='click'&&event.button == 0)||(event.type=='keypress'&&(event.charCode==KeyEvent.DOM_VK_SPACE||event.keyCode==KeyEvent.DOM_VK_RETURN)))&&gFireIE.goDoCommand('DisplaySecurityInfo')){event.stopPropagation();return;};";
-    hookCode("displaySecurityInfo", /{/, "$& " + displaySecurityInfoCode);
-    hookAttr("identity-box", "onclick", displaySecurityInfoCode);
-    hookAttr("identity-box", "onkeypress", displaySecurityInfoCode);
-    hookCode("gIdentityHandler.checkIdentity", /{/, "$& if (gFireIE.checkIdentity()) return; ");
-    hookCode("gIdentityHandler.onDragStart", "content.location.href", "gFireIE.getURL()");
+    hookBrowserGetter(gBrowser.mTabContainer.firstChild.linkedBrowser);
+  }
+  
+  function initListeners()
+  {
+    //event listeners
+    try
+    {
+      let container = gBrowser.tabContainer;
+      container.addEventListener("TabOpen", function(e) { hookBrowserGetter(e.target.linkedBrowser); }, true);
+      container.addEventListener("TabClose", function(e) { unhookBrowserGetter(e.target.linkedBrowser); }, false);
+    }
+    catch (ex)
+    {
+      Utils.ERROR("Failed to add tab open/close listeners: " + ex);
+    }
+    
+    try
+    {
+      let displaySecurityInfoHandler = function(event)
+      {
+        if ((typeof(event) == 'undefined'
+            || (event.type == 'click' && event.button == 0)
+            || (event.type == 'keypress'
+                && (event.charCode == KeyEvent.DOM_VK_SPACE || event.keyCode == KeyEvent.DOM_VK_RETURN)))
+          && gFireIE.goDoCommand('DisplaySecurityInfo'))
+        {
+          if (event) event.stopPropagation();
+        };
+      };
+      let identityBox = document.getElementById("identity-box");
+      identityBox.addEventListener("click", displaySecurityInfoHandler, true);
+      identityBox.addEventListener("keypress", displaySecurityInfoHandler, true);
+      identityBox.addEventListener("dragstart", function(event)
+      {
+        if (gFireIE.isIEEngine())
+        {
+          if (gURLBar.getAttribute("pageproxystate") != "valid") {
+            return;
+          }
+          var value = gFireIE.getURL();
+          var urlString = value + "\n" + content.document.title;
+          var htmlString = "<a href=\"" + value + "\">" + value + "</a>";
+          var dt = event.dataTransfer;
+          dt.setData("text/x-moz-url", urlString);
+          dt.setData("text/uri-list", value);
+          dt.setData("text/plain", value);
+          dt.setData("text/html", htmlString);
+        }
+      });
+    }
+    catch (e)
+    {
+      Utils.ERROR("Failed to add event listener on #identity-box");
+    }
+
     gFireIE.gIdentityHandler = gIdentityHandler;
-    hookCode("BrowserViewSourceOfDocument", /{/, "$& if(gFireIE.goDoCommand('ViewPageSource')) return;");
-    hookCode("getBrowserSelection", /{/, "$& { let gFireIE_value = gFireIE.getSelectionText(arguments[0]); if (gFireIE_value != null) return gFireIE_value; }"); // make firegestures' and others' selection based functions work
+  }
+  
+  function initLazyHooks()
+  {
+    // lazy function hooking, may solve most of the addon incompatibilities
+    // caused by the new hook mechanism
+    let delayedCheckTab = function(tab)
+    {
+      setTimeout(function() { if (gFireIE.isIEEngine(tab)) doLazyHooks(); }, 0);
+    };
+    let lazyHookTabOpenHandler = function(e)
+    {
+      delayedCheckTab(e.target);
+    };
+    let lazyHookDocumentCompleteHandler = function(e)
+    {
+      // make sure it is not from the utils plugin
+      if (document.getElementById(Utils.utilsPluginId) !== e.target)
+        doLazyHooks();
+    };
+    // add listeners
+    window.addEventListener("IEContentPluginInitialized", doLazyHooks, true);
+    window.addEventListener("IEDocumentComplete", lazyHookDocumentCompleteHandler, true);
+    let container = gBrowser.tabContainer;
+    container.addEventListener("TabOpen", lazyHookTabOpenHandler, true);
+    // listener removal
+    let removeLazyHookHandlers = function()
+    {
+      window.removeEventListener("IEContentPluginInitialized", doLazyHooks, true);
+      window.removeEventListener("IEDocumentComplete", lazyHookDocumentCompleteHandler, true);
+      container.removeEventListener("TabOpen", lazyHookTabOpenHandler, true);
+    };
+    // last thing: check whether the first tab is using IE engine
+    delayedCheckTab(gBrowser.mTabContainer.firstChild);
+    
+    let bLazyHooked = false;
+    function doLazyHooks()
+    {
+      // guard
+      if (bLazyHooked) return;
+      bLazyHooked = true;
+      removeLazyHookHandlers();
+      
+      Utils.LOG("Doing lazy function hooks...");
+      
+      //hook properties
+      hookURLBarSetter(gURLBar);
+
+      //hook functions
+      // Obtain real URL when bookmarking
+      HM.hookCodeHeadTail("PlacesCommandHook.bookmarkPage",
+                          function(aBrowser) { aBrowser.FireIE_bUseRealURI = true; },
+                          function(ret, aBrowser) { aBrowser.FireIE_bUseRealURI = false; });
+      {
+        let browsers = [];
+        HM.hookCodeHeadTail("PlacesControllerDragHelper.onDrop",
+          function(ip, dt)
+          {
+            browsers = [];
+            let dropCount = dt.mozItemCount;
+            for (let i = 0; i < dropCount; ++i) {
+              let flavor = this.getFirstValidFlavor(dt.mozTypesAt(i));
+              if (!flavor) return;
+              let data = dt.mozGetDataAt(flavor, i);
+              if (data instanceof XULElement && data.localName == "tab" && data.linkedBrowser)
+              {
+                data.linkedBrowser.FireIE_bUseRealURI = true;
+                browsers.push(data.linkedBrowser);
+              }
+            }
+          },
+          function(ret, ip, dt)
+          {
+            browsers.forEach(function(browser)
+            {
+              browser.FireIE_bUseRealURI = false;
+            });
+          });
+      }
+
+      // Show bookmark state (the star icon in URL bar) when using IE engine
+      HM.hookCodeHeadTail("PlacesStarButton.updateState",
+                          function() { gBrowser.mCurrentBrowser.FireIE_bUseRealURI = true; },
+                          function() { gBrowser.mCurrentBrowser.FireIE_bUseRealURI = false; });
+
+      // Show number of bookmarks in the overlay editing panel when using IE engine
+      HM.hookCodeHeadTail("StarUI._doShowEditBookmarkPanel",
+                          function() { gBrowser.mCurrentBrowser.FireIE_bUseRealURI = true; },
+                          function() { gBrowser.mCurrentBrowser.FireIE_bUseRealURI = false; });
+      
+
+      // Cancel setTabTitle when using IE engine
+      HM.hookCodeHead("gBrowser.setTabTitle", function(aTab)
+      {
+        let browser = this.getBrowserForTab(aTab);
+        if (browser.contentTitle) return;
+        if (browser.currentURI.spec && browser.currentURI.spec.indexOf(gFireIE.Utils.containerUrl) == 0)
+          return RET.shouldReturn();
+      });
+
+      // Visit the new URL
+      HM.hookCodeTail("getShortcutOrURI", function(ret) RET.modifyValue(gFireIE.getHandledURL(ret)));
+
+      //hook Interface Commands
+      HM.hookCodeHead("BrowserBack", function() { if (gFireIE.goDoCommand('Back')) return RET.shouldReturn(); });
+      HM.hookCodeHead("BrowserForward", function() { if (gFireIE.goDoCommand('Forward')) return RET.shouldReturn(); });
+      HM.hookCodeHead("BrowserStop", function() { if (gFireIE.goDoCommand('Stop')) return RET.shouldReturn(); });
+      HM.hookCodeHead("BrowserReload", function() { if (gFireIE.goDoCommand('Refresh')) return RET.shouldReturn(); });
+      HM.hookCodeHead("BrowserReloadSkipCache", function() { if (gFireIE.goDoCommand('Refresh')) return RET.shouldReturn(); });
+      HM.hookCodeHead("saveDocument", function() { if (gFireIE.goDoCommand('SaveAs')) return RET.shouldReturn(); });
+      HM.hookCodeHead("MailIntegration.sendMessage", function()
+      {
+        let pluginObject = gFireIE.getContainerPlugin();
+        if(pluginObject)
+        {
+          arguments[0] = pluginObject.URL;
+          arguments[1] = pluginObject.Title;
+          return RET.modifyArguments(arguments);
+        }
+      }); // @todo Send mail?
+      
+      HM.hookCodeHead("PrintUtils.print", function() { if(gFireIE.goDoCommand('Print')) return RET.shouldReturn(); });
+      HM.hookCodeHead("PrintUtils.showPageSetup", function() { if (gFireIE.goDoCommand('PrintSetup')) return RET.shouldReturn(); });
+      HM.hookCodeHead("PrintUtils.printPreview", function() { if (gFireIE.goDoCommand('PrintPreview')) return RET.shouldReturn(); });
+      // cmd_cut, cmd_copy, cmd_paste, cmd_selectAll
+      HM.hookCodeHead("goDoCommand", function() { if (gFireIE.goDoCommand(arguments[0])) return RET.shouldReturn(); }); 
+      
+      let displaySecurityInfoFunc = function()
+      {
+        if (gFireIE.goDoCommand('DisplaySecurityInfo'))
+          return RET.shouldReturn();
+      }
+      HM.hookCodeHead("displaySecurityInfo", displaySecurityInfoFunc);
+      HM.hookCodeHead("gIdentityHandler.checkIdentity", function() { if (gFireIE.checkIdentity()) return RET.shouldReturn(); });    
+      HM.hookCodeHead("BrowserViewSourceOfDocument", function() { if(gFireIE.goDoCommand('ViewPageSource')) return RET.shouldReturn(); });
+      
+      // make firegestures' and others' selection based functions work
+      HM.hookCodeHead("getBrowserSelection", function()
+      {
+        let value = gFireIE.getSelectionText(arguments[0]);
+        if (value != null) return RET.shouldReturn(value);
+      });
+
+      initializeFindBarHooks();
+    }
+  }
+
+  function initializeHooks()
+  {
+    initBasicHooks();
+    initListeners();
+    initLazyHooks();
 
-    initializeFindBarHooks();
     gFireIE.fireAfterInit(function()
     {
       initializeFGHooks();
@@ -84,61 +326,92 @@ var gFireIE = null;
       GesturePrefObserver.onGestureDetectionEnd();
       GesturePrefObserver.setEnabledGestures();
     }, this, []);
+
   }
 
   function initializeFindBarHooks()
   {
-    hookCode("gFindBar.onFindAgainCommand", /{/, "$& if (gFindBar.getElement('findbar-textbox').value.length != 0 && gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value, gFindBar.getElement('highlight').checked, gFindBar.getElement('find-case-sensitive').checked) && gFireIE.goDoCommand(arguments[0] ? 'FindPrevious' : 'FindAgain')) { gFireIE.updateFindBarUI(gFindBar); return; }"); // find_next, find_prev, arguments[0] denotes whether find_prev
+    // find_next, find_prev, arguments[0] denotes whether find_prev
+    HM.hookCodeHead("gFindBar.onFindAgainCommand", function()
+    {
+      if (gFindBar.getElement('findbar-textbox').value.length != 0
+        && gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value,
+                                 gFindBar.getElement('highlight').checked,
+                                 gFindBar.getElement('find-case-sensitive').checked)
+        && gFireIE.goDoCommand(arguments[0] ? 'FindPrevious' : 'FindAgain'))
+      {
+        gFireIE.updateFindBarUI(gFindBar);
+        return RET.shouldReturn();
+      }
+    });
 
-    // bug: toggling case sensitivity bypasses this oncommand property, use hookCode instead
-    hookCode("gFindBar.toggleHighlight", /{/, "$& if (gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value, gFindBar.getElement('highlight').checked, gFindBar.getElement('find-case-sensitive').checked)) { gFireIE.updateFindBarUI(gFindBar); return; }");
+    HM.hookCodeHead("gFindBar.toggleHighlight", function()
+    {
+      if (gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value,
+                                gFindBar.getElement('highlight').checked,
+                                gFindBar.getElement('find-case-sensitive').checked))
+      {
+        gFireIE.updateFindBarUI(gFindBar);
+        return RET.shouldReturn();
+      }
+    });
 
     // do not return in order to let findbar set the case sensitivity pref
-    hookAttr(gFindBar.getElement("find-case-sensitive"), "oncommand", "if (gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value, gFindBar.getElement('highlight').checked, gFindBar.getElement('find-case-sensitive').checked)) { gFireIE.updateFindBarUI(gFindBar); }");
+    HM.hookAttr(gFindBar.getElement("find-case-sensitive"), "oncommand", "if (gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value, gFindBar.getElement('highlight').checked, gFindBar.getElement('find-case-sensitive').checked)) { gFireIE.updateFindBarUI(gFindBar); }");
 
-    hookCode("gFindBar._find", /{/, "$& { let gFireIE_value = arguments[0] || gFindBar.getElement('findbar-textbox').value; if (gFireIE.setFindParams(gFireIE_value, gFindBar.getElement('highlight').checked, gFindBar.getElement('find-case-sensitive').checked) && gFireIE.findText(gFireIE_value)) { gFireIE.updateFindBarUI(gFindBar); return; }; }");
+    HM.hookCodeHead("gFindBar._find", function()
+    {
+      let value = arguments[0] || gFindBar.getElement('findbar-textbox').value;
+      if (gFireIE.setFindParams(value, gFindBar.getElement('highlight').checked,
+                                gFindBar.getElement('find-case-sensitive').checked)
+        && gFireIE.findText(value))
+      {
+        gFireIE.updateFindBarUI(gFindBar);
+        return RET.shouldReturn();
+      }
+    });
 
     // disabled, in order to support F3 findNext/Prev
     //hookCode("gFindBar.close", /{/, "$& if (!this.hidden) gFireIE.endFindText();");
 
-    hookAttr("cmd_find", "oncommand", "gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value, gFindBar.getElement('highlight').checked, gFindBar.getElement('find-case-sensitive').checked); gFireIE.resetFindBarUI(gFindBar);", true);
+    HM.hookAttrTail(document.getElementById("cmd_find"), "oncommand", "gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value, gFindBar.getElement('highlight').checked, gFindBar.getElement('find-case-sensitive').checked); gFireIE.resetFindBarUI(gFindBar);");
 
-    hookCode("gFindBar._getInitialSelection", /{/, "$& { let gFireIE_value = gFireIE.getSelectionText(this._selectionMaxLen); if (gFireIE_value != null) return gFireIE_value; }");
+    HM.hookCodeHead("gFindBar._getInitialSelection", function()
+    {
+      let value = gFireIE.getSelectionText(this._selectionMaxLen);
+      if (value != null) return RET.shouldReturn(value);
+    });
 
     try
     {
       gFindBar.getElement("findbar-textbox").addEventListener('keypress', function(event)
       {
-          var shouldHandle = !event.altKey && !event.ctrlKey &&
-                             !event.metaKey && !event.shiftKey;
+        var shouldHandle = !event.altKey && !event.ctrlKey &&
+                           !event.metaKey && !event.shiftKey;
 
-          switch (event.keyCode) {
-            case KeyEvent.DOM_VK_PAGE_UP:
-              if (shouldHandle) {
-                gFireIE.goDoCommand("PageUp");
-              }
-              break;
-            case KeyEvent.DOM_VK_PAGE_DOWN:
-              if (shouldHandle) {
-                gFireIE.goDoCommand("PageDown");
-              }
-              break;
-            case KeyEvent.DOM_VK_UP:
-              gFireIE.goDoCommand("LineUp");
-              break;
-            case KeyEvent.DOM_VK_DOWN:
-              gFireIE.goDoCommand("LineDown");
-              break;
-          }
+        switch (event.keyCode)
+        {
+          case KeyEvent.DOM_VK_PAGE_UP:
+            if (shouldHandle)
+              gFireIE.goDoCommand("PageUp");
+            break;
+          case KeyEvent.DOM_VK_PAGE_DOWN:
+            if (shouldHandle)
+              gFireIE.goDoCommand("PageDown");
+            break;
+          case KeyEvent.DOM_VK_UP:
+            gFireIE.goDoCommand("LineUp");
+            break;
+          case KeyEvent.DOM_VK_DOWN:
+            gFireIE.goDoCommand("LineDown");
+            break;
+        }
       });
     }
     catch (ex)
     {
       Utils.ERROR("findbar-textbox addEventListener('keypress') failed. " + ex);
     }    
-    //hookAttr("cmd_find", "oncommand", "if(gFireIE.goDoCommand('Find')) return;");
-    //hookAttr("cmd_findAgain", "oncommand", "if(gFireIE.goDoCommand('Find')) return;");
-    //hookAttr("cmd_findPrevious", "oncommand", "if(gFireIE.goDoCommand('Find')) return;");
   }
 
   // FireGestures support
@@ -148,8 +421,13 @@ var gFireIE = null;
     {
       Utils.LOG("Fire Gestures detected.");
       GesturePrefObserver.setGestureExtension("FireGestures");
-      hookCode("FireGestures._performAction", /{/, "$& if (gFireIE.goDoFGCommand(arguments[1])) return;");
-      hookCode("FireGestures.getSelectedText", /{/, "$& { let gFireIE_value = gFireIE.getSelectionText(1000, true); if (gFireIE_value != null) return gFireIE_value; }"); // make firegestures' selection based functions work
+      HM.hookCodeHead("FireGestures._performAction", function() { if (gFireIE.goDoFGCommand(arguments[1])) return RET.shouldReturn(); });
+      // make firegestures' selection based functions work
+      HM.hookCodeHead("FireGestures.getSelectedText", function()
+      {
+        let value = gFireIE.getSelectionText(1000, true);
+        if (value != null) return RET.shouldReturn(value);
+      });
     }
   }
 
@@ -162,8 +440,8 @@ var gFireIE = null;
       GesturePrefObserver.setGestureExtension("MouseGesturesRedox");
       function hookMGRFunction(name)
       {
-        if (mgGestureFunctions[name])
-          hookCode("mgGestureFunctions." + name, /{/, "$& if (gFireIE.goDoMGRCommand('" + name + "')) return;");
+        if (typeof(mgGestureFunctions[name]) == "function")
+          HM.hookCodeHead("mgGestureFunctions." + name, function() { if (gFireIE.goDoMGRCommand(name)) return RET.shouldReturn(); });
       }
       let functionList = ['mgW_ScrollDown', 'mgW_ScrollUp', 'mgW_ScrollLeft', 'mgW_ScrollRight'];
       for (let i = 0; i < functionList.length; i++)
@@ -183,7 +461,7 @@ var gFireIE = null;
       function hookAiOGFunction(name, action)
       {
         if (typeof(eval(name)) == "function")
-          hookCode(name, /{/, "$& if (gFireIE.goDoAiOGCommand('" + action + "', arguments)) return;");
+          HM.hookCodeHead(name, function() { if (gFireIE.goDoAiOGCommand(action, arguments)) return RET.shouldReturn(); });
       }
       let functionList = [["aioVScrollDocument", "vscroll"]];
       for (let i = 0; i < functionList.length; i++)
@@ -201,96 +479,53 @@ var gFireIE = null;
       GesturePrefObserver.setGestureExtension("GeneralAll");
     }
   }
-
-  function hookCode(orgFunc, orgCode, myCode)
+  
+  // save space by reusing function handles
+  let currentURIGetter = function()
   {
-    try
-    {
-      if (eval(orgFunc).toString() == eval(orgFunc + "=" + eval(orgFunc).toString().replace(orgCode, myCode))) throw orgFunc;
-    }
-    catch (e)
+    let uri = gFireIE.getURI(this);
+    if (uri)
     {
-      Utils.ERROR("Failed to hook function: " + orgFunc);
+      if (this.FireIE_bUseRealURI)
+        uri = makeURI(Utils.fromContainerUrl(uri.spec));
+      return RET.shouldReturn(uri);
     }
-  }
-
-
-  /** Replace attribute's value V with (myFunc + V) (or (V + myFunc) if insertAtEnd is set to true) */
-
-  function hookAttr(parentNode, attrName, myFunc, insertAtEnd)
-  {
-    if (typeof(parentNode) == "string") parentNode = document.getElementById(parentNode);
-    try
-    {
-      parentNode.setAttribute(attrName,
-        insertAtEnd ? parentNode.getAttribute(attrName) + myFunc
-                    : myFunc + parentNode.getAttribute(attrName));
-    }
-    catch (e)
-    {
-      Utils.ERROR("Failed to hook attribute: " + attrName);
-    }
-  }
-
-  /** Add some code at the beginning of Property's getter and setter */
-
-  function hookProp(parentNode, propName, myGetter, mySetter)
+  };
+  let sessionHistoryGetter = function()
   {
-    let oGetter = parentNode.__lookupGetter__(propName);
-    let oSetter = parentNode.__lookupSetter__(propName);
-    if (oGetter && myGetter) myGetter = oGetter.toString().replace(/{/, "{" + myGetter.toString().replace(/^.*{/, "").replace(/.*}$/, ""));
-    if (oSetter && mySetter) mySetter = oSetter.toString().replace(/{/, "{" + mySetter.toString().replace(/^.*{/, "").replace(/.*}$/, ""));
-    if (!myGetter) myGetter = oGetter;
-    if (!mySetter) mySetter = oSetter;
-    if (myGetter)
-    {
-      try
-      {
-        eval('parentNode.__defineGetter__(propName, ' + myGetter.toString() + ');');
-      }
-      catch (e)
-      {
-        Utils.ERROR("Failed to hook property Getter: " + propName);
-      }
-    }
-    if (mySetter)
+    let history = this.webNavigation.sessionHistory;
+    let uri = gFireIE.getURI(this);
+    if (uri)
     {
-      try
-      {
-        eval('parentNode.__defineSetter__(propName, ' + mySetter.toString() + ');');
-      }
-      catch (e)
+      let entry = history.getEntryAtIndex(history.index, false);
+      if (entry.URI.spec != uri.spec)
       {
-        Utils.ERROR("Failed to hook property Setter: " + propName);
+        entry.QueryInterface(Components.interfaces.nsISHEntry).setURI(uri);
+        if (this.parentNode.__SS_data) delete this.parentNode.__SS_data;
       }
     }
-  }
+  };
 
-  gFireIE.hookBrowserGetter = function(aBrowser)
+  function hookBrowserGetter(aBrowser)
   {
     if (aBrowser.localName != "browser") aBrowser = aBrowser.getElementsByTagNameNS(kXULNS, "browser")[0];
+    if (aBrowser.FireIE_hooked) return;
     // hook aBrowser.currentURI, Let firefox know the new URL after navigating inside the IE engine
-    hookProp(aBrowser, "currentURI", function()
-    {
-      let uri = gFireIE.getURI(this);
-      if (uri) return uri;
-    });
+    HM.hookProp(aBrowser, "currentURI", currentURIGetter);
     // hook aBrowser.sessionHistory
-    hookProp(aBrowser, "sessionHistory", function()
-    {
-      let history = this.webNavigation.sessionHistory;
-      let uri = gFireIE.getURI(this);
-      if (uri)
-      {
-        let entry = history.getEntryAtIndex(history.index, false);
-        if (entry.URI.spec != uri.spec)
-        {
-          entry.QueryInterface(Components.interfaces.nsISHEntry).setURI(uri);
-          if (this.parentNode.__SS_data) delete this.parentNode.__SS_data;
-        }
-      }
-    });
-  }
+    HM.hookProp(aBrowser, "sessionHistory", sessionHistoryGetter);
+    aBrowser.FireIE_hooked = true;
+    Utils.LOG("Browser Getter hooked.");
+  };
+  
+  function unhookBrowserGetter(aBrowser)
+  {
+    if (aBrowser.localName != "browser") aBrowser = aBrowser.getElementsByTagNameNS(kXULNS, "browser")[0];
+    HM.unhookProp(aBrowser, "currentURI");
+    HM.unhookProp(aBrowser, "sessionHistory");
+    aBrowser.FireIE_hooked = false;
+    Utils.LOG("Browser Getter unhooked.");
+  };
 
   function hookURLBarSetter(aURLBar)
   {
@@ -305,20 +540,22 @@ var gFireIE = null;
         aURLBar.focus();
       }
     }
-    hookProp(aURLBar, "value", null, function()
+    HM.hookProp(aURLBar, "value", null, function()
     {
       let isIEEngine = arguments[0] && (arguments[0].substr(0, Utils.containerUrl.length) == Utils.containerUrl);
       if (isIEEngine)
       {
         arguments[0] = Utils.fromContainerUrl(arguments[0]);
+        return RET.modifyArguments(arguments);
       }
     });
   }
-
-  window.addEventListener("load", function()
+  
+  let loadListener = function()
   {
-    window.removeEventListener("load", arguments.callee, false);
+    window.removeEventListener("load", loadListener, false);
     gFireIE.init();
     initializeHooks();
-  }, false);
+  };
+  window.addEventListener("load", loadListener, false);
 })();
diff --git a/extension/chrome/content/rules.js b/extension/chrome/content/rules.js
index 01d8e66..1a79b33 100644
--- a/extension/chrome/content/rules.js
+++ b/extension/chrome/content/rules.js
@@ -15,6 +15,7 @@ function init()
     if (rule instanceof Rule)
       Utils.runAsync(SubscriptionActions.selectRule, SubscriptionActions, rule);
   }
+  document.getElementById("subscriptionsAutoUpdate").checked = Prefs.subscriptions_autoupdate;
 }
 
 /**
diff --git a/extension/chrome/content/rules.xul b/extension/chrome/content/rules.xul
index cb0a76e..dffe2be 100644
--- a/extension/chrome/content/rules.xul
+++ b/extension/chrome/content/rules.xul
@@ -137,10 +137,11 @@
     <tabpanels flex="1">
       <!-- subscripted switching rules -->  
       <tabpanel id="subscriptionsTab" orient="vertical" flex="1">
-        <hbox pack="end">
+        <hbox>
+          <checkbox id="subscriptionsAutoUpdate" label="&subscription.autoupdate;" accesskey="A" oncommand="Prefs.subscriptions_autoupdate=this.checked;" />
+          <spacer flex="1"/>
           <button id="selectSubscriptionButton" label="&addSubscription.label;" accesskey="&addSubscription.accesskey;" command="subscription-add-command"/>
         </hbox>
-
         <panel id="selectSubscriptionPanel" type="arrow" position="bottomcenter topleft"
                orient="vertical" onkeypress="SelectSubscription.keyPress(event);">
           <menuitem id="selectSubscriptionTemplate" hidden="true"
diff --git a/extension/chrome/locale/en/global.properties b/extension/chrome/locale/en/global.properties
index fb2b2ff..5031b42 100644
--- a/extension/chrome/locale/en/global.properties
+++ b/extension/chrome/locale/en/global.properties
@@ -10,6 +10,7 @@ fireie.security.partiallyEncrypted=Your connection to this site is only partiall
 fireie.security.encrypted=Your connection to this website is encrypted\nEncryption strenth: 
 fireie.security.encryption.bit=bit
 fireie.security.encryption.unknown=Unknown
+fireie.pbw.title=Warning: IE Engine Does Not Support Private Browsing
 Synchronizer.invalidUrl=Invalid URL
 Synchronizer.connectionError=Connection Error
 Synchronizer.invalidData=Invalid rule data
diff --git a/extension/chrome/locale/en/private.dtd b/extension/chrome/locale/en/private.dtd
index 6bbab94..8406666 100644
--- a/extension/chrome/locale/en/private.dtd
+++ b/extension/chrome/locale/en/private.dtd
@@ -2,4 +2,4 @@
 <!ENTITY privatebrowsingwarning.intro1 "You have started Private Browsing for &brandShortName;, but it is not supported by IE engine.">
 <!ENTITY privatebrowsingwarning.intro2 "If you start IE engine, your browser history, search history, download history, web form history, cookies, and temporary internet files will be recorded in IE history logs.">
 <!ENTITY privatewarning.whatShouldIDo.content "If you do not want your private data to be recorded, please switch back to &brandShortName; engine.">
-<!ENTITY privatewarning.expert.content "If you still want to start IE engine to view the pages, please click 'Continue'. Notice: Other &brandShortName; tabs not using IE engine are still in Private Browsing sessions.">
+<!ENTITY privatewarning.expert.content "If you still want to start IE engine to view the pages, please click 'Resume'. Notice: Other &brandShortName; tabs not using IE engine are still in Private Browsing sessions.">
diff --git a/extension/chrome/locale/en/rules.dtd b/extension/chrome/locale/en/rules.dtd
index 984176c..db61d8f 100644
--- a/extension/chrome/locale/en/rules.dtd
+++ b/extension/chrome/locale/en/rules.dtd
@@ -3,6 +3,7 @@
 <!ENTITY subscriptions.tab.label              "Rule subscriptions">
 <!ENTITY rules.tab.label                    "Custom rules">
 
+<!ENTITY subscription.autoupdate              "Update automatically">
 <!ENTITY addSubscription.label                "Add rule subscription">
 <!ENTITY addSubscription.accesskey            "f">
 
diff --git a/extension/chrome/locale/zh-CN/global.properties b/extension/chrome/locale/zh-CN/global.properties
index b51f4c7..31727e8 100644
--- a/extension/chrome/locale/zh-CN/global.properties
+++ b/extension/chrome/locale/zh-CN/global.properties
@@ -10,6 +10,7 @@ fireie.security.partiallyEncrypted=您与此站点的连接仅仅被部分加密
 fireie.security.encrypted=您和此网站的连接已被加密\n加密强度：
 fireie.security.encryption.bit=位
 fireie.security.encryption.unknown=未知
+fireie.pbw.title=警告：IE 引擎不支持隐私浏览模式
 Synchronizer.invalidUrl=无效的URL
 Synchronizer.connectionError=网络连接错误
 Synchronizer.invalidData=规则数据格式不正确
diff --git a/extension/chrome/locale/zh-CN/rules.dtd b/extension/chrome/locale/zh-CN/rules.dtd
index d4be9ac..34220d5 100644
--- a/extension/chrome/locale/zh-CN/rules.dtd
+++ b/extension/chrome/locale/zh-CN/rules.dtd
@@ -1,6 +1,7 @@
 <!ENTITY dialog.title "解雇IE切换规则参数">
 <!ENTITY subscriptions.tab.label "已订阅的规则">
 <!ENTITY rules.tab.label "自定义规则">
+<!ENTITY subscription.autoupdate "自动更新">
 <!ENTITY addSubscription.label "订阅新规则">
 <!ENTITY addSubscription.accesskey "f">
 <!ENTITY addSubscriptionAdd.label "订阅">
diff --git a/extension/chrome/locale/zh-TW/global.properties b/extension/chrome/locale/zh-TW/global.properties
index 662074c..49ca88f 100644
--- a/extension/chrome/locale/zh-TW/global.properties
+++ b/extension/chrome/locale/zh-TW/global.properties
@@ -10,6 +10,7 @@ fireie.security.partiallyEncrypted=您與此網站的連接僅僅被部分加密
 fireie.security.encrypted=您和此網站的連接已被加密\n加密強度：
 fireie.security.encryption.bit=位
 fireie.security.encryption.unknown=未知
+fireie.pbw.title=警告：IE 引擎不支援隱私瀏覽模式
 Synchronizer.invalidUrl=無效的URL
 Synchronizer.connectionError=網路連接錯誤
 Synchronizer.invalidData=規則數據格式不正確
diff --git a/extension/chrome/locale/zh-TW/rules.dtd b/extension/chrome/locale/zh-TW/rules.dtd
index f03e896..2ebcc47 100644
--- a/extension/chrome/locale/zh-TW/rules.dtd
+++ b/extension/chrome/locale/zh-TW/rules.dtd
@@ -1,6 +1,7 @@
 <!ENTITY dialog.title "解雇IE切換規則參數">
 <!ENTITY subscriptions.tab.label "已訂閱的規則">
 <!ENTITY rules.tab.label "自定義規則">
+<!ENTITY subscription.autoupdate "自動更新">
 <!ENTITY addSubscription.label "訂閱新規則">
 <!ENTITY addSubscription.accesskey "f">
 <!ENTITY addSubscriptionAdd.label "訂閱">
diff --git a/extension/defaults/preferences/fireie.js b/extension/defaults/preferences/fireie.js
index af1ee07..c8126ac 100644
--- a/extension/defaults/preferences/fireie.js
+++ b/extension/defaults/preferences/fireie.js
@@ -3,6 +3,7 @@ pref("dom.ipc.plugins.enabled.npfireie64.dll", false);
 pref("extensions.fireie.privatebrowsingwarning", true);
 
 pref("extensions.fireie.currentVersion", "0.0.9");
+pref("extensions.fireie.subscriptions_defaultAdded", false);
 pref("extensions.fireie.subscriptions_autoupdate", true);
 pref("extensions.fireie.subscriptions_listurl", "http://fireie.org/sites/rules/subscriptions.xml");
 pref("extensions.fireie.subscriptions_fallbackurl", "https://fireie.org/getSubscription?version=%VERSION%&url=%SUBSCRIPTION%&downloadURL=%URL%&error=%ERROR%&channelStatus=%CHANNELSTATUS%&responseStatus=%RESPONSESTATUS%");
diff --git a/extension/install.rdf b/extension/install.rdf
index 071e64a..a49bba6 100644
--- a/extension/install.rdf
+++ b/extension/install.rdf
@@ -5,7 +5,7 @@
 
    <em:id>fireie@fireie.org</em:id>
    <em:name>Fire IE</em:name>
-   <em:version>0.2.5</em:version>
+   <em:version>0.2.7</em:version>
    <em:description>Switch to IE engine in one click and give up your Internet Explorer.</em:description>
    <em:creator>Yuan Xulei</em:creator>
    <em:contributor>Wei Deng</em:contributor>
@@ -21,7 +21,7 @@
      <Description>
        <em:id>{ec8030f7-c20a-464f-9b0e-13a3a9e97384}</em:id>
        <em:minVersion>4.0</em:minVersion>
-       <em:maxVersion>16.*</em:maxVersion>
+       <em:maxVersion>17.0a1</em:maxVersion>
      </Description>
    </em:targetApplication>
    
diff --git a/extension/modules/AppIntegration.jsm b/extension/modules/AppIntegration.jsm
index 28a761b..8f95d46 100644
--- a/extension/modules/AppIntegration.jsm
+++ b/extension/modules/AppIntegration.jsm
@@ -42,6 +42,7 @@ Cu.import(baseURL.spec + "RuleClasses.jsm");
 Cu.import(baseURL.spec + "SubscriptionClasses.jsm");
 Cu.import(baseURL.spec + "Synchronizer.jsm");
 Cu.import(baseURL.spec + "LightweightTheme.jsm");
+Cu.import(baseURL.spec + "IECookieManager.jsm");
 
 /**
  * Wrappers for tracked application windows.
@@ -93,44 +94,48 @@ let AppIntegration = {
   /**
    * Adds an application window to the tracked list.
    */
-  addWindow: function( /**Window*/ window)
+  addWindow: function( /**Window*/ window) /**WindowWrapper*/
   {
     // Execute first-run actions
     // Show subscriptions dialog if the user doesn't have any subscriptions yet
-    if (Prefs.currentVersion != Utils.addonVersion)
+    Utils.fireWithAddonVersion(function(addonVersion)
     {
-      Prefs.currentVersion = Utils.addonVersion;
-
-      if ("nsISessionStore" in Ci)
+      if (Prefs.currentVersion != addonVersion)
       {
-        // Have to wait for session to be restored
-        let observer = {
-          QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
-          observe: function(subject, topic, data)
-          {
-            observerService.removeObserver(observer, "sessionstore-windows-restored");
-            timer.cancel();
-            timer = null;
-            addSubscription();
-          }
-        };
+        Prefs.currentVersion = addonVersion;
 
-        let observerService = Cc["@mozilla.org/observer-service;1"].getService(Ci.nsIObserverService);
-        observerService.addObserver(observer, "sessionstore-windows-restored", false);
-
-        // Just in case, don't wait more than two seconds
-        let timer = Cc['@mozilla.org/timer;1'].createInstance(Ci.nsITimer);
-        timer.init(observer, 2000, Ci.nsITimer.TYPE_ONE_SHOT);
-      }
-      else
-      {
-        addSubscription();
+        if ("nsISessionStore" in Ci)
+        {
+          // Have to wait for session to be restored
+          let observer = {
+            QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
+            observe: function(subject, topic, data)
+            {
+              observerService.removeObserver(observer, "sessionstore-windows-restored");
+              timer.cancel();
+              timer = null;
+              addSubscription();
+            }
+          };
+
+          let observerService = Cc["@mozilla.org/observer-service;1"].getService(Ci.nsIObserverService);
+          observerService.addObserver(observer, "sessionstore-windows-restored", false);
+
+          // Just in case, don't wait more than two seconds
+          let timer = Cc['@mozilla.org/timer;1'].createInstance(Ci.nsITimer);
+          timer.init(observer, 2000, Ci.nsITimer.TYPE_ONE_SHOT);
+        }
+        else
+        {
+          addSubscription();
+        }
       }
-    }
+    });
 
     let wrapper = new WindowWrapper(window);
     wrappers.push(wrapper);
-
+    
+    return wrapper;
   },
 
   /**
@@ -274,6 +279,10 @@ WindowWrapper.prototype = {
    */
   _installUtilsPlugin: function()
   {
+    // Change the default cookie and cache directories of the IE, which will
+    // be restored when the utils plugin is loaded.
+    IECookieManager.changeIETempDirectorySetting();
+
     // Workaround for #35: Re-apply focus if URL is focused when utils plugin finishes initialization
     this.window.addEventListener("IEUtilsPluginInitialized", this._bindMethod(function()
     {
@@ -296,6 +305,7 @@ WindowWrapper.prototype = {
     embed.hidden = true;
     embed.setAttribute("id", Utils.utilsPluginId);
     embed.setAttribute("type", "application/fireie");
+    embed.style.visibility = "collapse";
     let mainWindow = this.E("main-window");
     mainWindow.appendChild(embed);
   },
@@ -344,6 +354,7 @@ WindowWrapper.prototype = {
   /**
    * Updates the UI for an application window.
    */
+  updateInterface: function() { this._updateInterface(); },
   _updateInterface: function()
   {
     if (this.isUpdating)
@@ -390,6 +401,10 @@ WindowWrapper.prototype = {
         this.checkIdentity();
         // update status text
         this.updateIEStatusText();
+        // update current tab's title
+        let title = pluginObject.Title;
+        if (title && title != "")
+          this.window.gBrowser.contentDocument.title = title;
       }
 
       // Update the star button indicating whether current page is bookmarked.
@@ -579,7 +594,7 @@ WindowWrapper.prototype = {
 
   /**
    *  Get current navigation URI with current engine.
-   *  It's of the same function with 与WindowWrapper#getURL.
+   *  It's of the same function with WindowWrapper#getURL.
    */
   getURI: function(aBrowser)
   {
@@ -988,17 +1003,17 @@ WindowWrapper.prototype = {
       
       if (Prefs.showStatusText)
       {
-        let event = this.window.gBrowser.contentDocument.createEvent("Event");
+        let event = this.window.gBrowser.contentDocument.createEvent("DataContainerEvent");
         event.initEvent("SetStatusText", false, false);
-        event.statusText = pluginObject.StatusText;
+        event.setData("statusText", pluginObject.StatusText);
         statusBar.dispatchEvent(event);
       }
       else if (!statusBar.hidden && !Prefs.showStatusText)
       {
         // event to notify content doc to hide status text
-        let event = this.window.gBrowser.contentDocument.createEvent("Event");
+        let event = this.window.gBrowser.contentDocument.createEvent("DataContainerEvent");
         event.initEvent("SetStatusText", false, false);
-        event.statusText = "";
+        event.setData("statusText", "");
         statusBar.dispatchEvent(event);
       }
     }
@@ -1121,10 +1136,7 @@ WindowWrapper.prototype = {
 
   _restoreIETempDirectorySetting: function()
   {
-    let subject = null;
-    let topic = "fireie-restoreIETempDirectorySetting";
-    let data = null;
-    Services.obs.notifyObservers(subject, topic, data);
+    IECookieManager.retoreIETempDirectorySetting();
   },
   
   // whether we should handle textbox commands, e.g. cmd_paste
@@ -1926,18 +1938,11 @@ function reloadPrefs()
  */
 function addSubscription()
 {
-  // Don't add subscription if the user has a subscription already
-  let needAdd = true;
-  if (RuleStorage.subscriptions.some(function(subscription) subscription instanceof DownloadableSubscription)) needAdd = false;
-
-  // Only add subscription if user has no rules
-  if (needAdd)
-  {
-    let hasRules = RuleStorage.subscriptions.some(function(subscription) subscription.rules.length);
-    if (hasRules) needAdd = false;
-  }
-
+  // Use a one-time pref to determine whether we should add default subscription
+  let needAdd = Prefs.subscriptions_defaultAdded ? false : true;
+  needAdd = needAdd && RuleStorage.subscriptions.length == 0;
   if (!needAdd) return;
+  Prefs.subscriptions_defaultAdded = true;
 
   function notifyUser()
   {
diff --git a/extension/modules/ContentPolicy.jsm b/extension/modules/ContentPolicy.jsm
index d49b35d..c9b65c2 100644
--- a/extension/modules/ContentPolicy.jsm
+++ b/extension/modules/ContentPolicy.jsm
@@ -190,23 +190,23 @@ var PolicyPrivate = {
       {
         if (!(subject instanceof Ci.nsIHttpChannel)) return;
 
-        if (Prefs.autoswitch_enabled)
+        let url = subject.URI.spec;
+        let domain = null;
+        let wnd = Utils.getRequestWindow(subject);
+        if (wnd)
         {
-          let url = subject.URI.spec;
-          let domain = null;
-          let wnd = Utils.getRequestWindow(subject);
-          if (wnd)
-          {
-            domain = Utils.getHostname(wnd.location.href);
-          }
+          domain = Utils.getHostname(wnd.location.href);
+        }
 
-          // Changes the UserAgent to that of IE if necessary.
-          if (Policy.checkUserAgentRule(url, domain) && Utils.ieUserAgent)
-          {
-            // Change user agent
-            subject.setRequestHeader("user-agent", Utils.ieUserAgent, false);
-          }
+        // Changes the UserAgent to that of IE if necessary.
+        if (Policy.checkUserAgentRule(url, domain) && Utils.ieUserAgent)
+        {
+          // Change user agent
+          subject.setRequestHeader("user-agent", Utils.ieUserAgent, false);
+        }
 
+        if (Prefs.autoswitch_enabled)
+        {
           // Checks whether we need switch to IE 
           let isWindowURI = subject.loadFlags & Ci.nsIChannel.LOAD_INITIAL_DOCUMENT_URI;
           if (isWindowURI)
diff --git a/extension/modules/HookManager.jsm b/extension/modules/HookManager.jsm
new file mode 100644
index 0000000..9afe2f3
--- /dev/null
+++ b/extension/modules/HookManager.jsm
@@ -0,0 +1,538 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/**
+ * @fileOverview HookManager, manages code hooking routines
+ */
+
+let EXPORTED_SYMBOLS = ["HookManager"];
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+const Cu = Components.utils;
+
+let baseURL = Cc["@fireie.org/fireie/private;1"].getService(Ci.nsIURI);
+
+Cu.import(baseURL.spec + "Utils.jsm");
+
+/**
+ * Stores information about a hooked function
+ * @param name - describes the original function's name (for error logging)
+ * @param orgFunc - original function reference
+ * @param myFuncHead - function that executes before original function
+ * @param myFuncTail - function that executes after original function
+ */
+let HookFunction = function(name, orgFunc, myFuncHead, myFuncTail) {
+  this.name = name;
+  this.orgFunc = orgFunc;
+  this.myFuncHead = myFuncHead;
+  this.myFuncTail = myFuncTail;
+};
+
+/**
+ * HookManager class, provides closure-preserving hooks without introducing new closures
+ * @param globalScope - the global scope that hooked function names can be referenced in
+ * @param globalReferencableName - the name that can be used to reference this HM instance
+ *                                 in the global scope
+ */
+let HookManager = function(globalScope, globalReferencableName) {
+  this._scope = globalScope;
+  this._refName = globalReferencableName;
+  this._hookFunctions = [];
+  this._recycledIndices = [];
+};
+
+HookManager.prototype = {
+  get globalScope() { return this._scope; },
+  get globalReferencableName() { return this._refName; },
+  get utils() { return Utils; },
+  
+  _addHookFunction: function(hf)
+  {
+    let idx = 0;
+    if (this._recycledIndices.length == 0)
+    {
+      idx = this._hookFunctions.length;
+      this._hookFunctions.push(hf);
+    }
+    else
+    {
+      idx = this._recycledIndices.pop();
+      this._hookFunctions[idx] = hf;
+    }
+    return idx;
+  },
+  
+  _recycleFunc: function(func)
+  {
+    let idx = func.FireIE_orgFuncIdx;
+    if (idx == this._hookFunctions.length - 1)
+      this._hookFunctions.pop();
+    else
+    {
+      this._hookFunctions[idx] = null;
+      this._recycledIndices.push(idx);
+    }
+  },
+  
+  _closureVarsCode: "  let grn = [grn];\n"
+                  + "  let hf = grn._hookFunctions[[idx]];\n"
+                  + "  let Utils = grn.utils;\n"
+                  + "  let funcName = hf.name;\n"
+                  + "  let orgFunc = hf.orgFunc;\n"
+                  + "  let myFuncHead = hf.myFuncHead;\n"
+                  + "  let myFuncTail = hf.myFuncTail;\n",
+  
+  _genClosureVarsCode: function(idx)
+  {
+    return this._closureVarsCode.replace(/\[grn\]/, this._refName).replace(/\[idx\]/, idx);
+  },
+  
+  _wrapFunctionHeadCode: 
+        "(function() {\n"
+      + "[gcvc]"
+      + "  let ret = null;\n"
+      + "  try {\n"
+      + "    ret = myFuncHead.apply(this, arguments);\n"
+      + "    if (ret && ret.shouldReturn)\n"
+      + "      return ret.value;\n"
+      + "  } catch (ex) {\n"
+      + "    Utils.ERROR('Failed executing hooked function: \"' + funcName + '\"@head: ' + ex);\n"
+      + "  }\n"
+      + "  let newArguments = (ret && ret.arguments) || arguments;\n"
+      + "  return orgFunc.apply(this, newArguments);\n"
+      + "})",
+
+  _wrapFunctionHead: function(orgFunc, myFunc, funcName)
+  {
+    let idx = this._addHookFunction(new HookFunction(funcName, orgFunc, myFunc, null));
+    let code = this._wrapFunctionHeadCode.replace(/\[gcvc\]/, this._genClosureVarsCode(idx));
+    with (this._scope) // in order to let the reference [grn] work
+    {
+      let func = eval(code);
+      func.FireIE_orgFuncIdx = idx;
+      return func;
+    }
+  },
+  
+  _wrapFunctionTailCode:
+        "(function() {\n"
+      + "[gcvc]"
+      + "  let ret = orgFunc.apply(this, arguments);\n"
+      + "  Array.prototype.splice.call(arguments, 0, 0, ret);\n"
+      + "  let myRet = null;\n"
+      + "  try {\n"
+      + "    myRet = myFuncTail.apply(this, arguments);\n"
+      + "  } catch (ex) {\n"
+      + "    Utils.ERROR('Failed executing hooked function: \"' + funcName + '\"@tail: ' + ex);\n"
+      + "  }\n"
+      + "  return (myRet && myRet.shouldModify) ? myRet.value : ret;\n"
+      + "})",
+      
+  _wrapFunctionTail: function(orgFunc, myFunc, funcName)
+  {
+    let idx = this._addHookFunction(new HookFunction(funcName, orgFunc, null, myFunc));
+    let code = this._wrapFunctionTailCode.replace(/\[gcvc\]/, this._genClosureVarsCode(idx));
+    with (this._scope) // in order to let the reference [grn] work
+    {
+      let func = eval(code);
+      func.FireIE_orgFuncIdx = idx;
+      return func;
+    }
+  },
+  
+  _wrapFunctionHeadTailCode:
+        "(function() {\n"
+      + "[gcvc]"
+      + "  let ret = null;\n"
+      + "  try {\n"
+      + "    ret = myFuncHead.apply(this, arguments);\n"
+      + "    if (ret && ret.shouldReturn)\n"
+      + "      return ret.value;\n"
+      + "  } catch (ex) {\n"
+      + "    Utils.ERROR('Failed executing hooked function: \"' + funcName + '\"@head: ' + ex);\n"
+      + "  }\n"
+      + "  let newArguments = (ret && ret.arguments) || arguments;\n"
+      + "  let orgRet = null, myRet = null;\n"
+      + "  try {\n"
+      + "    orgRet = orgFunc.apply(this, newArguments);\n"
+      + "  } finally {\n"
+      + "    Array.prototype.splice.call(newArguments, 0, 0, orgRet);\n"
+      + "    try {\n"
+      + "      myRet = myFuncTail.apply(this, newArguments);\n"
+      + "    } catch (ex) {\n"
+      + "      Utils.ERROR('Failed executing hooked function: \"' + funcName + '\"@tail: ' + ex);\n"
+      + "    }\n"
+      + "  }\n"
+      + "  return (myRet && myRet.shouldModify) ? myRet.value : orgRet;\n"
+      + "})",
+      
+  _wrapFunctionHeadTail: function(orgFunc, myFuncHead, myFuncTail, funcName)
+  {
+    let idx = this._addHookFunction(new HookFunction(funcName, orgFunc, myFuncHead, myFuncTail));
+    let code = this._wrapFunctionHeadTailCode.replace(/\[gcvc\]/, this._genClosureVarsCode(idx));
+    let func;
+    with (this._scope)
+    {
+      let func = eval(code);
+      func.FireIE_orgFuncIdx = idx;
+      return func;
+    }
+  },
+  
+  _getOriginalFunc: function(func)
+  {
+    let idx = func.FireIE_orgFuncIdx;
+    if (typeof(idx) == "number")
+    {
+      let hf = this._hookFunctions[idx];
+      if (hf instanceof HookFunction)
+        return hf.orgFunc;
+    }
+    return null;
+  },
+  
+  // specify hook function return values
+  RET: {
+    // hook @ head should return without calling orgFunc
+    shouldReturn: function(value)
+    {
+      return { shouldReturn: true, value: value };
+    },
+    // hook @ head should modify arguments passed to orgFunc
+    modifyArguments: function(arguments)
+    {
+      return { shouldReturn: false, arguments: arguments };
+    },
+    // hook @ tail should modify the return value
+    modifyValue: function(value)
+    {
+      return { shouldModify: true, value: value };
+    }
+  },
+  
+  /** 
+   * Add a hook to the beginning of a globally referencable function
+   * The safer way: hook code while preserving original function's closures
+   * @param orgFuncName - the name that can reference the function to hook in global scope
+   * @param myFunc - hook function to call at the beginning of the original function
+   */
+  hookCodeHead: function(orgFuncName, myFunc)
+  {
+    try
+    {
+      let orgFunc;
+      with (this._scope) { orgFunc = eval(orgFuncName); }
+      if (typeof(orgFunc) == "function")
+      {
+        let wrappedFunc = this._wrapFunctionHead(orgFunc, myFunc, orgFuncName);
+        // execute the assignment
+        eval("with (this._scope) { " + orgFuncName + "=wrappedFunc; }");
+        let orgFuncNew;
+        // check whether we are successful
+        with (this._scope) { orgFuncNew = eval(orgFuncName); }
+        if (wrappedFunc !== orgFuncNew)
+        {
+          this._recycleFunc(wrappedFunc);
+          throw "eval assignment failure";
+        }
+
+        return orgFunc;
+      }
+      else throw "not a function";
+    }
+    catch (ex)
+    {
+      Utils.ERROR("Failed to hook function " + orgFuncName + "@head: " + ex);
+    }
+  },
+  
+  /** 
+   * Add a hook to the end of a globally referencable function
+   * @param orgFuncName - the name that can reference the function to hook in global scope
+   * @param myFunc - hook function to call at the end of the original function
+   */
+  hookCodeTail: function(orgFuncName, myFunc)
+  {
+    try
+    {
+      let orgFunc;
+      with (this._scope) { orgFunc = eval(orgFuncName); }
+      if (typeof(orgFunc) == "function")
+      {
+        let wrappedFunc = this._wrapFunctionTail(orgFunc, myFunc, orgFuncName);
+        // execute the assignment
+        eval("with (this._scope) { " + orgFuncName + "=wrappedFunc; }");
+        let orgFuncNew;
+        // check whether we are successful
+        with (this._scope) { orgFuncNew = eval(orgFuncName); }
+        if (wrappedFunc !== orgFuncNew)
+        {
+          this._recycleFunc(wrappedFunc);
+          throw "eval assignment failure";
+        }
+
+        return orgFunc;
+      }
+      else throw "not a function";
+    }
+    catch (ex)
+    {
+      Utils.ERROR("Failed to hook function " + orgFuncName + "@tail: " + ex);
+    }
+  },
+  
+  /** 
+   * Add hooks to the beginning & end of a globally referencable function
+   * @param orgFuncName - the name that can reference the function to hook in global scope
+   * @param myFuncHead - hook function to call at the beginning of the original function
+   * @param myFuncTail - hook function to call at the end of the original function
+   */
+  hookCodeHeadTail: function(orgFuncName, myFuncHead, myFuncTail)
+  {
+    try
+    {
+      let orgFunc;
+      with (this._scope) { orgFunc = eval(orgFuncName); }
+      if (typeof(orgFunc) == "function")
+      {
+        let wrappedFunc = this._wrapFunctionHeadTail(orgFunc, myFuncHead, myFuncTail, orgFuncName);
+        // execute the assignment
+        eval("with (this._scope) { " + orgFuncName + "=wrappedFunc; }");
+        let orgFuncNew;
+        // check whether we are successful
+        with (this._scope) { orgFuncNew = eval(orgFuncName); }
+        if (wrappedFunc !== orgFuncNew)
+        {
+          this._recycleFunc(wrappedFunc);
+          throw "eval assignment failure";
+        }
+
+        return orgFunc;
+      }
+      else throw "not a function";
+    }
+    catch (ex)
+    {
+      Utils.ERROR("Failed to hook function " + orgFuncName + "@head&tail: " + ex);
+    }
+  },
+  
+  /** 
+   * Unhook a previously hooked function
+   * @param orgFuncName - the name that can reference the hooked function in global scope
+   */
+  unhookCode: function(orgFuncName)
+  {
+    try
+    {
+      let hookedFunc;
+      with (this._scope) { hookedFunc = eval(orgFuncName); }
+      if (typeof(hookedFunc) == "function")
+      {
+        let orgFunc = this._getOriginalFunc(hookedFunc);
+        if (orgFunc)
+        {
+          // execute the eval that restores original function
+          eval("with (this._scope) { " + orgFuncName + " = orgFunc; }");
+          // check whether we are successful
+          let orgFuncNew;
+          with (this._scope) { orgFuncNew = eval(orgFuncName); }
+          if (orgFunc !== orgFuncNew)
+            throw "eval assignment failure";
+          // successful, reclaim func idx
+          this._recycleFunc(hookedFunc);
+          return hookedFunc;
+        }
+      }
+      throw "not hooked or broken hook";
+    }
+    catch (ex)
+    {
+      Utils.ERROR("Failed to unhook function " + orgFuncName + ": " + ex);
+    }
+  },
+
+  /**
+   * Replace attribute's value V with (myFunc + V) (or (V + myFunc) if insertAtEnd is set to true)
+   * @param parentNode - the node whose attribute is to be hooked
+   * @param attrName - the name of the attribute to hook
+   * @param myFunc - the code string to append
+   * @param insertAtEnd - whether insert the code at the beginning or the end
+   */
+  hookAttr: function(parentNode, attrName, myFunc, insertAtEnd)
+  {
+    if (typeof(parentNode) == "string")
+      throw "Hook attr using string name of the node is not supported."
+    try
+    {
+      let attr = parentNode.getAttribute(attrName);
+      parentNode.setAttribute(attrName,
+        insertAtEnd ? attr + myFunc : myFunc + attr);
+      return attr;
+    }
+    catch (ex)
+    {
+      Utils.ERROR("Failed to hook attribute " + attrName + ": " + ex);
+    }
+  },
+  
+  /**
+   * The insert-at-end version of hookAttr
+   */
+  hookAttrTail: function(parentNode, attrName, myFunc)
+  {
+    return this.hookAttr(parentNode, attrName, myFunc, true);
+  },
+  
+  /**
+   * Add some code at the beginning of Property's getter and setter
+   * This one uses wrapFunctionHead,
+   * which is safe to preserve original getter/setter's closure
+   * @param parentNode - the node whose property is to be hooked
+   * @param propName - the name of the property to hook
+   * @param myGetter - the function to be called at the beginning of the getter
+   * @param mySetter - the function to be called at the beginning of the setter
+   */
+  hookProp: function(parentNode, propName, myGetter, mySetter)
+  {
+    // must set both getter and setter or the other will be missing
+    let oGetter = parentNode.__lookupGetter__(propName);
+    let oSetter = parentNode.__lookupSetter__(propName);
+    if (oGetter && myGetter)
+    {
+      let newGetter = this._wrapFunctionHead(oGetter, myGetter, parentNode.toString() + ".get " + propName);
+      try
+      {
+        parentNode.__defineGetter__(propName, newGetter);
+      }
+      catch (ex)
+      {
+        Utils.ERROR("Failed to hook property Getter " + propName + ": " + ex);
+      }
+    }
+    else if (oGetter)
+    {
+      parentNode.__defineGetter__(propName, oGetter);
+    }
+    if (oSetter && mySetter)
+    {
+      let newSetter = this._wrapFunctionHead(oSetter, mySetter, parentNode.toString() + ".set " + propName);
+      try
+      {
+        parentNode.__defineSetter__(propName, newSetter);
+      }
+      catch (ex)
+      {
+        Utils.ERROR("Failed to hook property Setter " + propName + ": " + ex);
+      }
+    }
+    else if (oSetter)
+    {
+      parentNode.__defineSetter__(propName, oSetter);
+    }
+    return { getter: oGetter, setter: oSetter };
+  },
+  
+  /**
+   * Unhook previously hooked property getter and setter
+   * @param parentNode - the node whose property is to be unhooked
+   * @param propName - the name of the property to unhook
+   */
+  unhookProp: function(parentNode, propName)
+  {
+    // must set both getter and setter or the other will be missing
+    let myGetter = parentNode.__lookupGetter__(propName);
+    let mySetter = parentNode.__lookupSetter__(propName);
+    let oGetter = (myGetter && this._getOriginalFunc(myGetter)) || myGetter;
+    let oSetter = (mySetter && this._getOriginalFunc(mySetter)) || mySetter;
+    if (oGetter) parentNode.__defineGetter__(propName, oGetter);
+    if (oSetter) parentNode.__defineSetter__(propName, oSetter);
+    if (oGetter != myGetter) this._recycleFunc(myGetter);
+    if (oSetter != mySetter) this._recycleFunc(mySetter);
+    return { getter: myGetter, setter: mySetter };
+  },
+  
+  /**
+   * Redirects dangerous source-patching hook functions to the original one
+   * @param funcName - the globally referencable name of the function used to do source-patching hook
+   * @param funcIdx - the index of function parameter in the above function
+   */
+  redirectSourcePatchingHook: function(funcName, funcIdx)
+  {
+    let orgFunc = null, orgHookFunction = null, HM = this;
+    return this.hookCodeHeadTail(funcName, function()
+    {
+      let func = arguments[funcIdx];
+      orgFunc = func;
+      let bModify = false;
+      // use "while" in case we wrapped several hook levels ourselves
+      while (typeof(func) == "function" && typeof(func.FireIE_orgFuncIdx) == "number")
+      {
+        bModify = true;
+        orgHookFunction = HM._hookFunctions[func.FireIE_orgFuncIdx];
+        func = orgHookFunction.orgFunc;
+      }
+      if (bModify)
+      {
+        Utils.LOG("Redirected source-patching hook for " + orgHookFunction.name);
+        arguments[funcIdx] = func;
+        return HM.RET.modifyArguments(arguments);
+      }
+    },
+    function(ret)
+    {
+      if (orgFunc != arguments[funcIdx + 1])
+      {
+        if (ret) orgHookFunction.orgFunc = ret;
+        return HM.RET.modifyValue(orgFunc);
+      }
+    });
+  },
+  
+  /**
+   * Redirects dangerous source-patching hook functions to the original one
+   * @param funcName - the globally referencable name of the function used to do source-patching hook
+   * @param nameIdx - the index of function name parameter in the above function
+   * @param funcIdx - the index of function parameter in the above function
+   */
+  redirectSPHNameFunc: function(funcName, nameIdx, funcIdx)
+  {
+    let HM = this;
+    return this.hookCodeHead(funcName, function()
+    {
+      let func = arguments[funcIdx];
+      let bModify = false;
+      let orgHookFunctionIdx = null;
+      // use "while" in case we wrapped several hook levels ourselves
+      while (typeof(func) == "function" && typeof(func.FireIE_orgFuncIdx) == "number")
+      {
+        bModify = true;
+        orgHookFunctionIdx = func.FireIE_orgFuncIdx;
+        func = HM._hookFunctions[orgHookFunctionIdx].orgFunc;
+      }
+      if (bModify)
+      {
+        arguments[nameIdx] = HM._refName + "._hookFunctions[" + orgHookFunctionIdx + "].orgFunc";
+        arguments[funcIdx] = func;
+        Utils.LOG("Redirected name-func SPH from " + HM._hookFunctions[orgHookFunctionIdx].name + " to " + arguments[nameIdx]);
+        return HM.RET.modifyArguments(arguments);
+      }
+    });
+  }
+};
diff --git a/extension/modules/IECookieManager.jsm b/extension/modules/IECookieManager.jsm
index 571ba1d..5bcb7b5 100644
--- a/extension/modules/IECookieManager.jsm
+++ b/extension/modules/IECookieManager.jsm
@@ -104,6 +104,7 @@ function setIECtrlRegString(regName, value)
 let IECookieManager = {
   wininetDll: null,
   _ieCookieMap: {},
+  _bTmpDirRestored: false,
   
   /**
    * Called on module startup.
@@ -113,10 +114,6 @@ let IECookieManager = {
     // User jsctypes to load the window api of InternetSetCookieW
     this._loadInternetSetCookieW();
 
-    // Change the default cookie and cache directories of the IE, which will
-    // be restored when the cookie plugin is loaded.
-    this.changeIETempDirectorySetting();
-
     CookieObserver.register();
   },
 
@@ -265,6 +262,9 @@ let IECookieManager = {
 
   changeIETempDirectorySetting: function()
   {
+    // safe guard: do not attempt to change after already restored
+    if (this._bTmpDirRestored) return;
+    
     let profileDir = Services.dirsvc.get("ProfD", Ci.nsIFile).path;
 
     let originalCookies = getIECtrlRegString("Cookies");
@@ -280,10 +280,16 @@ let IECookieManager = {
     {
       setIECtrlRegString("Cache", profileDir + "\\fireie\\cache");
     }
+    
+    Utils.LOG("IE Temp dir changed.");
   },
   
   retoreIETempDirectorySetting: function()
   {
+    if (this._bTmpDirRestored) return;
+  
+    this._bTmpDirRestored = true;
+    
     let cookies = getIECtrlRegString("Cookies_fireie");
     if (cookies)
     {
@@ -294,7 +300,8 @@ let IECookieManager = {
     {
       setIECtrlRegString("Cache", cache);
     }
-    
+
+    Utils.LOG("IE Temp dir restored.");
   },
 
   _getExpiresString: function(expiresInSeconds)
@@ -312,14 +319,12 @@ let CookieObserver = {
   {
     Services.obs.addObserver(this, "cookie-changed", false);
     Services.obs.addObserver(this, "fireie-set-cookie", false);
-    Services.obs.addObserver(this, "fireie-restoreIETempDirectorySetting", false);
   },
 
   unregister: function()
   {
     Services.obs.removeObserver(this, "cookie-changed");
     Services.obs.removeObserver(this, "fireie-set-cookie");
-    Services.obs.removeObserver(this, "fireie-restoreIETempDirectorySetting");
   },
 
   // nsIObserver
@@ -333,9 +338,6 @@ let CookieObserver = {
     case 'fireie-set-cookie':
       this.onIECookieChanged(data);
       break;
-    case 'fireie-restoreIETempDirectorySetting':
-      IECookieManager.retoreIETempDirectorySetting();
-      break;
     }
   },
 
diff --git a/extension/modules/RuleStorage.jsm b/extension/modules/RuleStorage.jsm
index c0ac9e3..e1347bf 100644
--- a/extension/modules/RuleStorage.jsm
+++ b/extension/modules/RuleStorage.jsm
@@ -76,7 +76,7 @@ var RuleStorage = {
       {}
     }
 
-    if (!file) Cu.reportError("Fire-IE: Failed to resolve rule file location from extensions.adblockplus.patternsfile preference");
+    if (!file) Cu.reportError("Fire-IE: Failed to resolve rule file location.");
 
     this.__defineGetter__("sourceFile", function() file);
     return this.sourceFile;
@@ -718,4 +718,4 @@ function parseIniFile( /**nsIUnicharLineInputStream*/ stream) /**Array of String
     }
     else if (wantObj === false && val) curObj.push(val.replace(/\\\[/g, "["));
   }
-}
\ No newline at end of file
+}
diff --git a/extension/modules/Utils.jsm b/extension/modules/Utils.jsm
index 08de107..7f989dc 100644
--- a/extension/modules/Utils.jsm
+++ b/extension/modules/Utils.jsm
@@ -20,6 +20,7 @@ Cu.import("resource://gre/modules/AddonManager.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
 let _addonVersion = null;
+let _addonVersionCallbacks = [];
 
 /**
  * Provides a bunch of utility functions.
@@ -748,6 +749,21 @@ var Utils = {
       }
     }
     return selectedItem;
+  },
+  // runs the callback function after the addon version is obtained
+  fireWithAddonVersion: function(callback)
+  {
+    if (_addonVersion != null)
+      callback(_addonVersion);
+    else
+      _addonVersionCallbacks.push(callback);
+  },
+  // truncate string if it's too long
+  saturateString: function(str, length)
+  {
+    if (str.length > length)
+      str = str.substring(0, length - 3) + "...";
+    return str;
   }
 };
 
@@ -770,6 +786,11 @@ var Utils = {
 AddonManager.getAddonByID(Utils.addonID, function(addon)
 {
   _addonVersion = addon.version;
+  _addonVersionCallbacks.forEach(function(callback)
+  {
+    callback(_addonVersion);
+  });
+  _addonVersionCallbacks = null;
 });
 
 (function() {
diff --git a/plugin/BrowserHook/WindowMessageHook.cpp b/plugin/BrowserHook/WindowMessageHook.cpp
index b04aff4..06cac7d 100644
--- a/plugin/BrowserHook/WindowMessageHook.cpp
+++ b/plugin/BrowserHook/WindowMessageHook.cpp
@@ -285,6 +285,10 @@ Exit:
 			case 'Y': // Ctrl+Y, redo 
 			case VK_HOME: // Ctrl+HOME, Scroll to Top
 			case VK_END:  // Ctrl+END, Scroll to end
+			case VK_LEFT: // Ctrl+L/R, Jump to prev/next word
+			case VK_RIGHT:
+			case VK_UP: // Ctrl+U/D, identical to Up/Down
+			case VK_DOWN:
 				return FALSE;
 			default:
 				return TRUE;
@@ -298,10 +302,18 @@ Exit:
 		{
 			switch (keyCode)
 			{
+			case VK_F2: // Developer toolbar, although not very useful
+				return bShiftPressed;
 			case VK_F3: // find next, with shift: find prev
 				return TRUE;
+			case VK_F4: // Shift-F4 opens Scratchpad which is very handy
+				return bShiftPressed;
+			case VK_F7: // Style Editor, although not very useful
+				return bShiftPressed;
 			case VK_F11: // full screen
 				return !bShiftPressed;
+			case VK_F12: // Firebug, although not really useful
+				return !bShiftPressed;
 			default:
 				return FALSE;
 			}
diff --git a/plugin/IEHostWindow.cpp b/plugin/IEHostWindow.cpp
index 915888b..ce64d3b 100644
--- a/plugin/IEHostWindow.cpp
+++ b/plugin/IEHostWindow.cpp
@@ -247,6 +247,11 @@ LRESULT CIEHostWindow::OnUserMessage(WPARAM wParam, LPARAM lParam)
 			OnUtilsPluginInit();
 		}
 		break;
+	case WPARAM_CONTENT_PLUGIN_INIT:
+		{
+			OnContentPluginInit();
+		}
+		break;
 	case WPARAM_NAVIGATE:
 		{
 			OnNavigate();
@@ -576,7 +581,7 @@ void CIEHostWindow::HandOverFocus()
 			if(htmlDoc) 
 			{
 				CComPtr<IHTMLWindow2> window;
-				if(SUCCEEDED(htmlDoc->get_parentWindow(&window))) 
+				if(SUCCEEDED(htmlDoc->get_parentWindow(&window)) && window) 
 				{
 					window->focus();
 				}
@@ -602,8 +607,7 @@ void CIEHostWindow::Zoom(double level)
 	// >= IE7
 	try
 	{
-		if (m_ie.GetSafeHwnd() && 
-			(m_ie.QueryStatusWB(OLECMDID_OPTICAL_ZOOM) & OLECMDF_ENABLED))
+		if (m_ie.GetSafeHwnd())
 		{
 			m_ie.ExecWB(OLECMDID_OPTICAL_ZOOM, OLECMDEXECOPT_DONTPROMPTUSER, &vZoomLevel, NULL);
 		}
@@ -686,6 +690,45 @@ void CIEHostWindow::ScrollHorizontal(bool left)
 	SendKey(left ? VK_LEFT : VK_RIGHT);
 }
 
+BOOL CALLBACK CIEHostWindow::GetInternetExplorerServerCallback(HWND hWnd, LPARAM lParam)
+{
+	CString strClassName;
+	GetClassName(hWnd, strClassName.GetBuffer(MAX_PATH), MAX_PATH);
+	strClassName.ReleaseBuffer(); 
+	if (strClassName == _T("Internet Explorer_Server"))
+	{
+		*(HWND*)lParam = hWnd;
+		return FALSE;
+	}
+	return TRUE;
+}
+
+HWND CIEHostWindow::GetInternetExplorerServer() const
+{
+	HWND parent = this->m_hWnd;
+	HWND hWnd = NULL;
+	EnumChildWindows(parent, GetInternetExplorerServerCallback, (LPARAM)&hWnd);
+	return hWnd;
+}
+
+void CIEHostWindow::ScrollWheelLine(bool up)
+{
+	POINT ptCursorPos;
+	GetCursorPos(&ptCursorPos);
+
+	HWND hWnd = GetInternetExplorerServer();
+	if (hWnd)
+	{
+		TRACE(_T("Found Internet Explorer_Server, scrolling...\n"));
+		::SendMessage(hWnd, WM_MOUSEWHEEL,
+			MAKEWPARAM(0, up ? WHEEL_DELTA : -WHEEL_DELTA), MAKELPARAM(ptCursorPos.x, ptCursorPos.y));
+	}
+	else
+	{
+		TRACE(_T("Internet Explorer_Server not found, scroll canceled.\n"));
+	}
+}
+
 CString CIEHostWindow::GetURL()
 {
 	CString url;
@@ -927,7 +970,7 @@ void CIEHostWindow::OnDisplaySecurityInfo()
 		if (!pSP) return;
 
 		CComQIPtr<IWebBrowser2> pWB2;
-		if (FAILED(pSP->QueryService(IID_IWebBrowserApp, &pWB2)))
+		if (FAILED(pSP->QueryService(IID_IWebBrowserApp, &pWB2)) || pWB2 == NULL)
 			return;
 
 		CComQIPtr<IOleCommandTarget> pCmd = pWB2;
@@ -948,6 +991,14 @@ void CIEHostWindow::OnUtilsPluginInit()
 	}
 }
 
+void CIEHostWindow::OnContentPluginInit()
+{
+	if (m_pPlugin)
+	{
+		m_pPlugin->OnContentPluginInit();
+	}
+}
+
 void CIEHostWindow::OnTitleChanged(const CString& title)
 {
 	if (m_pPlugin)
@@ -1239,10 +1290,10 @@ CString CIEHostWindow::GetSelectionTextFromDoc(const CComPtr<IHTMLDocument2>& pD
 	CString strFail = _T("");
 
 	CComPtr<IHTMLSelectionObject> pSO;
-	if (SUCCEEDED(pDoc->get_selection(&pSO)))
+	if (SUCCEEDED(pDoc->get_selection(&pSO)) && pSO)
 	{
 		CComPtr<IDispatch> pDisp2;
-		if (SUCCEEDED(pSO->createRange(&pDisp2)))
+		if (SUCCEEDED(pSO->createRange(&pDisp2)) && pDisp2)
 		{
 			CComQIPtr<IHTMLTxtRange> pTxtRange = pDisp2;
 			if (pTxtRange)
@@ -1259,7 +1310,7 @@ CString CIEHostWindow::GetSelectionTextFromDoc(const CComPtr<IHTMLDocument2>& pD
 
 	CComPtr<IHTMLFramesCollection2> pFrames;
 	long length;
-	if (SUCCEEDED(pDoc->get_frames(&pFrames)) && SUCCEEDED(pFrames->get_length(&length)))
+	if (SUCCEEDED(pDoc->get_frames(&pFrames)) && pFrames && SUCCEEDED(pFrames->get_length(&length)))
 	{
 		for (long i = 0; i < length; i++)
 		{
@@ -1270,7 +1321,7 @@ CString CIEHostWindow::GetSelectionTextFromDoc(const CComPtr<IHTMLDocument2>& pD
 				CComPtr<IDispatch> pDisp = vDisp.pdispVal;
 				CComQIPtr<IHTMLWindow2> pWindow;
 				CComPtr<IHTMLDocument2> pSubDoc;
-				if ((pWindow = pDisp) && SUCCEEDED(pWindow->get_document(&pSubDoc)))
+				if ((pWindow = pDisp) && SUCCEEDED(pWindow->get_document(&pSubDoc)) && pSubDoc)
 				{
 					CString text = GetSelectionTextFromDoc(pSubDoc);
 					if (text != strFail) return text;
@@ -1350,7 +1401,10 @@ void CIEHostWindow::FBFindText(const CString& text)
 {
 	FBSetFindText(text);
 	if (m_bFBInProgress)
+	{
+		if (!FBCheckDocument()) return;
 		FBRestartFind();
+	}
 }
 
 void CIEHostWindow::FBEndFindText()
@@ -1377,6 +1431,7 @@ void CIEHostWindow::FBSetFindText(const CString& text)
 			FBResetFindRange();
 		}
 	}
+	if (m_bFBInProgress && !FBCheckDocument()) return;
 	if (m_bFBInProgress && m_bFBHighlight)
 		FBHighlightAll();
 	else FBCancelHighlight();
@@ -1443,13 +1498,14 @@ bool CIEHostWindow::FBObtainFindRange()
 void CIEHostWindow::FBObtainFindRangeRecursive(const CComPtr<IHTMLDocument2>& pDoc)
 {
 	CComPtr<IHTMLElement> pBodyElem;
-	if (SUCCEEDED(pDoc->get_body(&pBodyElem)))
+	if (SUCCEEDED(pDoc->get_body(&pBodyElem)) && pBodyElem)
 	{
 		CComQIPtr<IHTMLBodyElement> pBody = pBodyElem;
 		if (pBody)
 		{
 			CComPtr<IHTMLTxtRange> pTxtRange, pOrgRange;
-			if (SUCCEEDED(pBody->createTextRange(&pTxtRange)) && SUCCEEDED(pTxtRange->duplicate(&pOrgRange)))
+			if (SUCCEEDED(pBody->createTextRange(&pTxtRange)) && pTxtRange
+				&& SUCCEEDED(pTxtRange->duplicate(&pOrgRange)) && pOrgRange)
 			{
 				m_vFBDocs.push_back(FBDocFindStatus(pDoc, pTxtRange, pOrgRange));
 			}
@@ -1490,7 +1546,7 @@ void CIEHostWindow::FBMatchDocSelection()
 		pMS->CreateMarkupPointer(&pMPStart);
 		pMS->CreateMarkupPointer(&pMPEnd);
 		CComPtr<IHTMLEditServices> pES;
-		if (pMPStart && pMPEnd && SUCCEEDED(pSP->QueryService(SID_SHTMLEditServices, &pES)))
+		if (pMPStart && pMPEnd && SUCCEEDED(pSP->QueryService(SID_SHTMLEditServices, &pES)) && pES)
 		{
 			pMS->MovePointersToRange(FBGetCurrentDocStatus().txtRange, pMPStart, pMPEnd);
 			pES->SelectRange(pMPStart, pMPEnd, SELECTION_TYPE_None);
@@ -1498,9 +1554,24 @@ void CIEHostWindow::FBMatchDocSelection()
 	}
 }
 
+bool CIEHostWindow::FBCheckDocument()
+{
+	for (long lCurrentDoc = 0; lCurrentDoc < static_cast<long>(m_vFBDocs.size()); lCurrentDoc++)
+	{
+		FBDocFindStatus& dfs = m_vFBDocs[lCurrentDoc];
+		CComPtr<IHTMLTxtRange> pTmpTxtRange;
+		if (dfs.txtRange == NULL || FAILED(dfs.txtRange->duplicate(&pTmpTxtRange)) || pTmpTxtRange == NULL)
+		{
+			return FBResetFindRange();
+		}
+	}
+	return true;
+}
+
 void CIEHostWindow::FBFindAgain()
 {
 	if (!m_bFBInProgress) return;
+	if (!FBCheckDocument()) return;
 	FBResetFindStatus();
 	FBFindAgainInternal(false);
 }
@@ -1534,8 +1605,15 @@ void CIEHostWindow::FBFindAgainInternal(bool backwards, bool norecur, bool nosel
 
 	CComBSTR bstr_Text = m_strFBText;
 	VARIANT_BOOL bFound = VARIANT_FALSE;
+	
 	CComPtr<IHTMLTxtRange> pTmpTxtRange;
 	dfs.txtRange->duplicate(&pTmpTxtRange);
+	if (!pTmpTxtRange)
+	{
+		FBResetFindRange();
+		return;
+	}
+
 	long length = m_strFBText.GetLength();
 
 	while (dfs.txtRange->findText(bstr_Text, backwards ? -0x7FFFFFFF : 0x7FFFFFFF, (m_bFBCase ? 4 : 0), &bFound), bFound)
@@ -1564,8 +1642,15 @@ void CIEHostWindow::FBFindAgainInternal(bool backwards, bool norecur, bool nosel
 		{
 			bool findSelfAgain = m_bFBTxtRangeChanged;
 			m_bFBTxtRangeChanged = false;
+
 			CComPtr<IHTMLTxtRange> pPrevTxtRange;
 			dfs.txtRange->duplicate(&pPrevTxtRange);
+			if (!pPrevTxtRange)
+			{
+				FBResetFindRange();
+				return;
+			}
+
 			dfs.txtRange->setEndPoint(CComBSTR("StartToStart"), dfs.originalRange);
 			dfs.txtRange->setEndPoint(CComBSTR("EndToEnd"), dfs.originalRange);
 
@@ -1610,6 +1695,7 @@ void CIEHostWindow::FBFindAgainInternal(bool backwards, bool norecur, bool nosel
 void CIEHostWindow::FBFindPrevious()
 {
 	if (!m_bFBInProgress) return;
+	if (!FBCheckDocument()) return;
 	FBResetFindStatus();
 	//FBFindAgainInternal(true);
 
@@ -1626,6 +1712,11 @@ void CIEHostWindow::FBFindPrevious()
 	{
 		lOriginalIndex = m_lFBCurrentDoc;
 		FBGetCurrentDocStatus().txtRange->duplicate(&pOriginalRange);
+		if (!pOriginalRange)
+		{
+			FBResetFindRange();
+			return;
+		}
 
 		// since backwards find always finds a correct match (although it might not be the closest one)
 		// we start from there, and it might be potentially faster, avoiding many visibility tests
@@ -1646,6 +1737,11 @@ void CIEHostWindow::FBFindPrevious()
 			m_lFBCurrentDoc = lOriginalIndex;
 			FBGetCurrentDocStatus().txtRange = NULL;
 			pOriginalRange->duplicate(&FBGetCurrentDocStatus().txtRange);
+			if (!FBGetCurrentDocStatus().txtRange)
+			{
+				FBResetFindRange();
+				return;
+			}
 			m_lFBLastFindLength = lLastFindLength;
 		}
 		do
@@ -1653,6 +1749,11 @@ void CIEHostWindow::FBFindPrevious()
 			lLastIndex = m_lFBCurrentDoc;
 			pLastRange = NULL;
 			FBGetCurrentDocStatus().txtRange->duplicate(&pLastRange);
+			if (!pLastRange)
+			{
+				FBResetFindRange();
+				return;
+			}
 			bLastCrossTail = m_bFBCrossTail;
 			m_bFBFound = false;
 			FBFindAgainInternal(false, false, true);
@@ -1698,6 +1799,7 @@ void CIEHostWindow::FBToggleHighlight(bool bHighlight)
 
 	FBResetFindStatusGood();
 
+	if (m_bFBInProgress && !FBCheckDocument()) return;
 	if (m_bFBInProgress && bHighlight)
 	{
 		FBHighlightAll();
@@ -1717,6 +1819,7 @@ void CIEHostWindow::FBToggleCase(bool bCase)
 
 	if (m_bFBInProgress)
 	{
+		if (!FBCheckDocument()) return;
 		if (m_bFBHighlight)
 			FBHighlightAll();
 	}
@@ -1739,6 +1842,12 @@ void CIEHostWindow::FBHighlightAll()
 
 		CComPtr<IHTMLTxtRange> pPrevTxtRange;
 		dfs.txtRange->duplicate(&pPrevTxtRange);
+		if (!pPrevTxtRange)
+		{
+			FBResetFindRange();
+			return;
+		}
+
 		dfs.txtRange->setEndPoint(CComBSTR("StartToStart"), dfs.originalRange);
 		dfs.txtRange->setEndPoint(CComBSTR("EndToEnd"), dfs.originalRange);
 
@@ -1752,7 +1861,7 @@ void CIEHostWindow::FBHighlightAll()
 			VARIANT_BOOL bFound;
 			long length = m_strFBText.GetLength();
 			CComPtr<IHTMLRenderStyle> pRenderStyle;
-			if (SUCCEEDED(pDoc4->createRenderStyle(NULL, &pRenderStyle)))
+			if (SUCCEEDED(pDoc4->createRenderStyle(NULL, &pRenderStyle)) && pRenderStyle)
 			{
 				pRenderStyle->put_defaultTextSelection(CComBSTR("false"));
 				pRenderStyle->put_textBackgroundColor(CComVariant("fuchsia"));
diff --git a/plugin/IEHostWindow.h b/plugin/IEHostWindow.h
index 9c8b5c5..11a946a 100644
--- a/plugin/IEHostWindow.h
+++ b/plugin/IEHostWindow.h
@@ -56,6 +56,7 @@ namespace UserMessage
 	static const WPARAM WPARAM_EXEC_OLE_CMD = 6;
 	static const WPARAM WPARAM_DISPLAY_SECURITY_INFO = 7;
 	static const WPARAM WPARAM_UTILS_PLUGIN_INIT = 8;
+	static const WPARAM WPARAM_CONTENT_PLUGIN_INIT = 9;
 
 }
 
@@ -91,6 +92,9 @@ public:
 	 * @return The IE control's UserAgent. It will be ready when the page completes loading for the first time. Before that, empty string will be returned.
 	 */
 	static CString GetIEUserAgentString() {return s_strIEUserAgent;}
+
+	/* Get the embedded Internet Explorer_server window */
+	HWND GetInternetExplorerServer() const;
 		
 public:
 	
@@ -184,9 +188,12 @@ protected:
 	void FBHighlightAll();
 	void FBCancelHighlight();
 	void FBMatchDocSelection();
+	bool FBCheckDocument();
 	static bool FBCheckRangeVisible(const CComPtr<IHTMLTxtRange>& pRange);
 	static bool FBRangesEqual(const CComPtr<IHTMLTxtRange>& pRange1, const CComPtr<IHTMLTxtRange>& pRange2);
 	static bool FBCheckRangeHighlightable(const CComPtr<IDisplayServices> pDS, const CComPtr<IMarkupServices> pMS, const CComPtr<IHTMLTxtRange>& pRange);
+
+	static BOOL CALLBACK GetInternetExplorerServerCallback(HWND hWnd, LPARAM lParam);
 public:
 	CIECtrl m_ie;
 
@@ -216,6 +223,7 @@ public:
 	void ScrollLine(bool up);
 	void ScrollWhole(bool up);
 	void ScrollHorizontal(bool left);
+	void ScrollWheelLine(bool up);
 
 	// FindBar methods
 	void FBFindText(const CString& text);
@@ -255,6 +263,7 @@ public:
 	void OnCloseIETab();
 	void OnSetSecureLockIcon(int state);
 	void OnUtilsPluginInit();
+	void OnContentPluginInit();
 
 protected:
 	BOOL m_bCanBack;
diff --git a/plugin/Plugin/ScriptablePluginObject.cpp b/plugin/Plugin/ScriptablePluginObject.cpp
index 33618a7..0ce6230 100644
--- a/plugin/Plugin/ScriptablePluginObject.cpp
+++ b/plugin/Plugin/ScriptablePluginObject.cpp
@@ -409,6 +409,18 @@ namespace Plugin
 			pMainWindow->ScrollHorizontal(false);
 			return true;
 		}
+		else if (name == NPI_ID(ScrollWheelUp))
+		{
+			TRACE ("ScrollWheelUp called!\n");
+			pMainWindow->ScrollWheelLine(true);
+			return true;
+		}
+		else if (name == NPI_ID(ScrollWheelDown))
+		{
+			TRACE ("ScrollWheelDown called!\n");
+			pMainWindow->ScrollWheelLine(false);
+			return true;
+		}
 		else if (name == NPI_ID(FBFindText))
 		{
 			TRACE ("FBFindText called!\n");
diff --git a/plugin/Plugin/ScriptablePluginObject.h b/plugin/Plugin/ScriptablePluginObject.h
index 7594a7b..aff966b 100644
--- a/plugin/Plugin/ScriptablePluginObject.h
+++ b/plugin/Plugin/ScriptablePluginObject.h
@@ -64,6 +64,8 @@ namespace Plugin
 		NPI_DEF(ScrollBottom);
 		NPI_DEF(ScrollLeft);
 		NPI_DEF(ScrollRight);
+		NPI_DEF(ScrollWheelUp);
+		NPI_DEF(ScrollWheelDown);
 
 		// findbar methods
 		NPI_DEF(FBFindText); // FB stands for firefox FindBar
@@ -132,6 +134,8 @@ namespace Plugin
 			NPN_GSI_M(ScrollBottom);
 			NPN_GSI_M(ScrollLeft);
 			NPN_GSI_M(ScrollRight);
+			NPN_GSI_M(ScrollWheelUp);
+			NPN_GSI_M(ScrollWheelDown);
 			NPN_GSI_M(FBFindText);
 			NPN_GSI_M(FBEndFindText);
 			NPN_GSI_M(FBFindAgain);
diff --git a/plugin/Plugin/plugin.cpp b/plugin/Plugin/plugin.cpp
index e0682a4..21e47a8 100644
--- a/plugin/Plugin/plugin.cpp
+++ b/plugin/Plugin/plugin.cpp
@@ -158,6 +158,16 @@ namespace Plugin
 			if (hwnd)
 				PostMessage(hwnd, UserMessage::WM_USER_MESSAGE, UserMessage::WPARAM_UTILS_PLUGIN_INIT, 0);
 		}
+		else
+		{
+			// content IE window, should fire IEContentPluginIntialized event
+
+			// cannot directly fire the event since the plugin is not fully constructed 
+			// - we are still in the initializer
+			HWND hwnd = m_pIEHostWindow->GetSafeHwnd();
+			if (hwnd)
+				PostMessage(hwnd, UserMessage::WM_USER_MESSAGE, UserMessage::WPARAM_CONTENT_PLUGIN_INIT, 0);
+		}
 
 		return TRUE;
 	}
@@ -656,4 +666,11 @@ namespace Plugin
 		CString strDetail = _T("");
 		FireEvent(strEventType, strDetail);
 	}
+
+	void CPlugin::OnContentPluginInit()
+	{
+		CString strEventType = _T("IEContentPluginInitialized");
+		CString strDetail = _T("");
+		FireEvent(strEventType, strDetail);
+	}
 }
diff --git a/plugin/Plugin/plugin.h b/plugin/Plugin/plugin.h
index a133bdf..b55c381 100644
--- a/plugin/Plugin/plugin.h
+++ b/plugin/Plugin/plugin.h
@@ -150,6 +150,9 @@ namespace Plugin
 
 		/** Utility plugin intialized */
 		void OnUtilsPluginInit();
+
+		/** Content plugin intialized */
+		void OnContentPluginInit();
 	protected:
 
 		NPP m_pNPInstance;
