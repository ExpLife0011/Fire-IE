diff --git a/extension/chrome/content/container.js b/extension/chrome/content/container.js
index f4931d2..0fc17e2 100644
--- a/extension/chrome/content/container.js
+++ b/extension/chrome/content/container.js
@@ -205,7 +205,9 @@ let FireIEContainer = {};
   function onSetStatusText(event)
   {
     let statusbar = E(Utils.statusBarId);
-    let statustext = event.statusText;
+    let statustext = event.getData("statusText");
+    if (typeof(statustext) == "undefined")
+      statustext = "";
     let pretext = "";
     if (statusbar.firstChild)
     {
@@ -240,38 +242,42 @@ let FireIEContainer = {};
       hideStatusBar();
   }
 
+  let mouseScrollBubbleProtect = false;
   function onDOMMouseScroll(event)
   {
-    // constants from Win API
-    const SCROLL_PAGE_DOWN = 32768;
-    const SCROLL_PAGE_UP = -32768;
-    
-    // If it's a plain mouse wheel scroll, set focus on the IE control
-    // in order to let user scroll the content
-    if (event.axis == event.VERTICAL_AXIS
-        && !event.ctrlKey && !event.shiftKey && !event.altKey && !event.metaKey)
-    {
-      // Gecko 15+ supports "buttons" attribute
-      if (typeof(event.buttons) == "undefined" || event.buttons == 0)
+    if (mouseScrollBubbleProtect) return;
+    mouseScrollBubbleProtect = true;
+
+    try {
+      // constants from Win API
+      const SCROLL_PAGE_DOWN = 32768;
+      const SCROLL_PAGE_UP = -32768;
+      
+      // If it's a plain mouse wheel scroll, set focus on the IE control
+      // in order to let user scroll the content
+      if (event.axis == event.VERTICAL_AXIS
+          && !event.ctrlKey && !event.shiftKey && !event.altKey && !event.metaKey)
       {
-        // it's a plain wheel scroll, transfer focus to the control
-        let pluginObject = E(Utils.containerPluginId);
-        if (pluginObject)
+        // Gecko 15+ supports "buttons" attribute
+        if (typeof(event.buttons) == "undefined" || event.buttons == 0)
         {
-          // note we're focusing the plugin object, not the plugin control
-          // the object's focus handler will help us transfer the window focus
-          pluginObject.focus();
-          // forward this scroll result (UP or DOWN) as it's not sent to the control
-          if (event.detail > 0)
+          // it's a plain wheel scroll, transfer focus to the control
+          let pluginObject = E(Utils.containerPluginId);
+          if (pluginObject)
           {
-            event.detail == SCROLL_PAGE_DOWN ? pluginObject.PageDown() : pluginObject.LineDown();
-          }
-          else if (event.detail < 0)
-          {
-            event.detail == SCROLL_PAGE_UP ? pluginObject.PageUp() : pluginObject.LineUp();
+            // note we're focusing the plugin object, not the plugin control
+            // the object's focus handler will help us transfer the window focus
+            pluginObject.focus();
+            // forward this scroll result (UP or DOWN) as it's not sent to the control
+            event.detail > 0 ? pluginObject.ScrollWheelDown() : pluginObject.ScrollWheelUp();
           }
         }
       }
+    } finally {
+      setTimeout(function()
+      {
+        mouseScrollBubbleProtect = false;
+      }, 500);
     }
   }
 
diff --git a/extension/chrome/content/firstRun.js b/extension/chrome/content/firstRun.js
index b8da048..e6823d7 100644
--- a/extension/chrome/content/firstRun.js
+++ b/extension/chrome/content/firstRun.js
@@ -23,9 +23,6 @@ function init()
       break;
     }
   }
-
-  if (RuleStorage.subscriptions.some(function(s) s.url == Prefs.subscriptions_exceptionsurl))
-    E("acceptableAds").hidden = false;
 }
 
 function generateLinkText(element)
diff --git a/extension/chrome/content/overlay.js b/extension/chrome/content/overlay.js
index 127a3a7..760ffa2 100644
--- a/extension/chrome/content/overlay.js
+++ b/extension/chrome/content/overlay.js
@@ -33,8 +33,7 @@ var gFireIE = null;
   {
     AppIntegration, Utils, GesturePrefObserver
   } = jsm;
-  AppIntegration.addWindow(window);
-  gFireIE = AppIntegration.getWrapperForWindow(window);
+  gFireIE = AppIntegration.addWindow(window);
 
   function initializeHooks()
   {
@@ -43,36 +42,141 @@ var gFireIE = null;
     hookURLBarSetter(gURLBar);
 
     //hook functions
-    hookCode("PlacesCommandHook.bookmarkPage", "aBrowser.currentURI", "makeURI(gFireIE.Utils.fromContainerUrl($&.spec))"); // Obtain real URL when bookmarking
-    hookCode("PlacesControllerDragHelper.onDrop", "data.linkedBrowser.currentURI", "makeURI(gFireIE.Utils.fromContainerUrl($&.spec))"); // Obtain real URL when bookmarking
-    hookCode("PlacesStarButton.updateState", /(gBrowser|getBrowser\(\))\.currentURI/g, "makeURI(gFireIE.Utils.fromContainerUrl($&.spec))"); // Show bookmark state (the star icon in URL bar) when using IE engine
-    hookCode("StarUI._doShowEditBookmarkPanel", /(gBrowser|getBrowser\(\))\.currentURI/g, "makeURI(gFireIE.Utils.fromContainerUrl($&.spec))"); // Show number of bookmarks in the overlay editing panel when using IE engine
-    hookCode("gBrowser.addTab", "return t;", "gFireIE.hookBrowserGetter(t.linkedBrowser); $&");
-    hookCode("gBrowser.setTabTitle", "if (browser.currentURI.spec) {", "$& if (browser.currentURI.spec.indexOf(gFireIE.Utils.containerUrl) == 0) return;"); // Cancel setTabTitle when using IE engine
-    hookCode("getShortcutOrURI", /return (\S+);/g, "return gFireIE.getHandledURL($1);"); // Visit the new URL
+    // Obtain real URL when bookmarking
+    hookCodeHeadTail("PlacesCommandHook.bookmarkPage",
+                     function(aBrowser) { aBrowser.FireIE_bUseRealURI = true; },
+                     function(ret, aBrowser) { aBrowser.FireIE_bUseRealURI = false; });
+    {
+      let browsers = [];
+      hookCodeHeadTail("PlacesControllerDragHelper.onDrop",
+        function(ip, dt)
+        {
+          browsers = [];
+          let dropCount = dt.mozItemCount;
+          for (let i = 0; i < dropCount; ++i) {
+            let flavor = this.getFirstValidFlavor(dt.mozTypesAt(i));
+            if (!flavor) return;
+            let data = dt.mozGetDataAt(flavor, i);
+            if (data instanceof XULElement && data.localName == "tab" && data.linkedBrowser)
+            {
+              data.linkedBrowser.FireIE_bUseRealURI = true;
+              browsers.push(data.linkedBrowser);
+            }
+          }
+        },
+        function(ret, ip, dt)
+        {
+          browsers.forEach(function(browser)
+          {
+            browser.FireIE_bUseRealURI = false;
+          });
+        });
+    }
+    // hookCode("PlacesControllerDragHelper.onDrop", "data.linkedBrowser.currentURI", "makeURI(gFireIE.Utils.fromContainerUrl($&.spec))");
+
+    // Show bookmark state (the star icon in URL bar) when using IE engine
+    hookCodeHeadTail("PlacesStarButton.updateState",
+                     function() { gBrowser.mCurrentBrowser.FireIE_bUseRealURI = true; },
+                     function() { gBrowser.mCurrentBrowser.FireIE_bUseRealURI = false; });
+
+                     // Show number of bookmarks in the overlay editing panel when using IE engine
+    hookCodeHeadTail("StarUI._doShowEditBookmarkPanel",
+                     function() { gBrowser.mCurrentBrowser.FireIE_bUseRealURI = true; },
+                     function() { gBrowser.mCurrentBrowser.FireIE_bUseRealURI = false; });
+    hookCodeTail("gBrowser.addTab", function(t) { gFireIE.hookBrowserGetter(t.linkedBrowser); });
+
+    // Cancel setTabTitle when using IE engine
+    hookCodeHead("gBrowser.setTabTitle", function(aTab)
+    {
+      let browser = this.getBrowserForTab(aTab);
+      if (browser.contentTitle) return;
+      if (browser.currentURI.spec && browser.currentURI.spec.indexOf(gFireIE.Utils.containerUrl) == 0)
+        return shouldReturn();
+    });
+
+    // Visit the new URL
+    hookCodeTail("getShortcutOrURI", function(ret) modifyValue(gFireIE.getHandledURL(ret)));
+
     //hook Interface Commands
-    hookCode("BrowserBack", /{/, "$& if(gFireIE.goDoCommand('Back')) return;");
-    hookCode("BrowserForward", /{/, "$& if(gFireIE.goDoCommand('Forward')) return;");
-    hookCode("BrowserStop", /{/, "$& if(gFireIE.goDoCommand('Stop')) return;");
-    hookCode("BrowserReload", /{/, "$& if(gFireIE.goDoCommand('Refresh')) return;");
-    hookCode("BrowserReloadSkipCache", /{/, "$& if(gFireIE.goDoCommand('Refresh')) return;");
-
-    hookCode("saveDocument", /{/, "$& if(gFireIE.goDoCommand('SaveAs')) return;");
-    hookCode("MailIntegration.sendMessage", /{/, "$& let pluginObject = gFireIE.getContainerPlugin(); if(pluginObject){ arguments[0]=pluginObject.URL; arguments[1]=pluginObject.Title; }"); // @todo Send mail?
-    hookCode("PrintUtils.print", /{/, "$& if(gFireIE.goDoCommand('Print')) return;");
-    hookCode("PrintUtils.showPageSetup", /{/, "$& if(gFireIE.goDoCommand('PrintSetup')) return;");
-    hookCode("PrintUtils.printPreview", /{/, "$& if(gFireIE.goDoCommand('PrintPreview')) return;");
-
-    hookCode("goDoCommand", /{/, "$& if(gFireIE.goDoCommand(arguments[0])) return;"); // cmd_cut, cmd_copy, cmd_paste, cmd_selectAll
-    let displaySecurityInfoCode = "if((typeof(event)=='undefined'||(event.type=='click'&&event.button == 0)||(event.type=='keypress'&&(event.charCode==KeyEvent.DOM_VK_SPACE||event.keyCode==KeyEvent.DOM_VK_RETURN)))&&gFireIE.goDoCommand('DisplaySecurityInfo')){event.stopPropagation();return;};";
-    hookCode("displaySecurityInfo", /{/, "$& " + displaySecurityInfoCode);
-    hookAttr("identity-box", "onclick", displaySecurityInfoCode);
-    hookAttr("identity-box", "onkeypress", displaySecurityInfoCode);
-    hookCode("gIdentityHandler.checkIdentity", /{/, "$& if (gFireIE.checkIdentity()) return; ");
-    hookCode("gIdentityHandler.onDragStart", "content.location.href", "gFireIE.getURL()");
+    hookCodeHead("BrowserBack", function() { if (gFireIE.goDoCommand('Back')) return shouldReturn(); });
+    hookCodeHead("BrowserForward", function() { if (gFireIE.goDoCommand('Forward')) return shouldReturn(); });
+    hookCodeHead("BrowserStop", function() { if (gFireIE.goDoCommand('Stop')) return shouldReturn(); });
+    hookCodeHead("BrowserReload", function() { if (gFireIE.goDoCommand('Refresh')) return shouldReturn(); });
+    hookCodeHead("BrowserReloadSkipCache", function() { if (gFireIE.goDoCommand('Refresh')) return shouldReturn(); });
+    hookCodeHead("saveDocument", function() { if (gFireIE.goDoCommand('SaveAs')) return shouldReturn(); });
+    hookCodeHead("MailIntegration.sendMessage", function()
+    {
+      let pluginObject = gFireIE.getContainerPlugin();
+      if(pluginObject)
+      {
+        arguments[0] = pluginObject.URL;
+        arguments[1] = pluginObject.Title;
+        return modifyArguments(arguments);
+      }
+    }); // @todo Send mail?
+    
+    hookCodeHead("PrintUtils.print", function() { if(gFireIE.goDoCommand('Print')) return shouldReturn(); });
+    hookCodeHead("PrintUtils.showPageSetup", function() { if (gFireIE.goDoCommand('PrintSetup')) return shouldReturn(); });
+    hookCodeHead("PrintUtils.printPreview", function() { if (gFireIE.goDoCommand('PrintPreview')) return shouldReturn(); });
+    // cmd_cut, cmd_copy, cmd_paste, cmd_selectAll
+    hookCodeHead("goDoCommand", function() { if (gFireIE.goDoCommand(arguments[0])) return shouldReturn(); }); 
+    
+    let displaySecurityInfoHandler = function(event)
+    {
+      if ((typeof(event) == 'undefined'
+          || (event.type == 'click' && event.button == 0)
+          || (event.type == 'keypress'
+              && (event.charCode == KeyEvent.DOM_VK_SPACE || event.keyCode == KeyEvent.DOM_VK_RETURN)))
+        && gFireIE.goDoCommand('DisplaySecurityInfo'))
+      {
+        event.stopPropagation();
+      };
+    };
+    let displaySecurityInfoFunc = function(e)
+    {
+      displaySecurityInfoHandler(e);
+      return shouldReturn();
+    }
+    hookCodeHead("displaySecurityInfo", displaySecurityInfoFunc);
+    
+    try
+    {
+      let identityBox = document.getElementById("identity-box");
+      identityBox.addEventListener("click", displaySecurityInfoHandler, true);
+      identityBox.addEventListener("keypress", displaySecurityInfoHandler, true);
+      identityBox.addEventListener("dragstart", function(event)
+      {
+        if (gFireIE.isIEEngine())
+        {
+          if (gURLBar.getAttribute("pageproxystate") != "valid") {
+            return;
+          }
+          var value = gFireIE.getURL();
+          var urlString = value + "\n" + content.document.title;
+          var htmlString = "<a href=\"" + value + "\">" + value + "</a>";
+          var dt = event.dataTransfer;
+          dt.setData("text/x-moz-url", urlString);
+          dt.setData("text/uri-list", value);
+          dt.setData("text/plain", value);
+          dt.setData("text/html", htmlString);
+        }
+      });
+    }
+    catch (e)
+    {
+      Utils.ERROR("Failed to add event listener on #identity-box");
+    }
+
     gFireIE.gIdentityHandler = gIdentityHandler;
-    hookCode("BrowserViewSourceOfDocument", /{/, "$& if(gFireIE.goDoCommand('ViewPageSource')) return;");
-    hookCode("getBrowserSelection", /{/, "$& { let gFireIE_value = gFireIE.getSelectionText(arguments[0]); if (gFireIE_value != null) return gFireIE_value; }"); // make firegestures' and others' selection based functions work
+    hookCodeHead("gIdentityHandler.checkIdentity", function() { if (gFireIE.checkIdentity()) return shouldReturn(); });    
+    hookCodeHead("BrowserViewSourceOfDocument", function() { if(gFireIE.goDoCommand('ViewPageSource')) return shouldReturn(); });
+    
+    // make firegestures' and others' selection based functions work
+    hookCodeHead("getBrowserSelection", function()
+    {
+      let value = gFireIE.getSelectionText(arguments[0]);
+      if (value != null) return shouldReturn(value);
+    });
 
     initializeFindBarHooks();
     gFireIE.fireAfterInit(function()
@@ -88,48 +192,81 @@ var gFireIE = null;
 
   function initializeFindBarHooks()
   {
-    hookCode("gFindBar.onFindAgainCommand", /{/, "$& if (gFindBar.getElement('findbar-textbox').value.length != 0 && gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value, gFindBar.getElement('highlight').checked, gFindBar.getElement('find-case-sensitive').checked) && gFireIE.goDoCommand(arguments[0] ? 'FindPrevious' : 'FindAgain')) { gFireIE.updateFindBarUI(gFindBar); return; }"); // find_next, find_prev, arguments[0] denotes whether find_prev
+    // find_next, find_prev, arguments[0] denotes whether find_prev
+    hookCodeHead("gFindBar.onFindAgainCommand", function()
+    {
+      if (gFindBar.getElement('findbar-textbox').value.length != 0
+        && gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value,
+                                 gFindBar.getElement('highlight').checked,
+                                 gFindBar.getElement('find-case-sensitive').checked)
+        && gFireIE.goDoCommand(arguments[0] ? 'FindPrevious' : 'FindAgain'))
+      {
+        gFireIE.updateFindBarUI(gFindBar);
+        return shouldReturn();
+      }
+    });
 
-    // bug: toggling case sensitivity bypasses this oncommand property, use hookCode instead
-    hookCode("gFindBar.toggleHighlight", /{/, "$& if (gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value, gFindBar.getElement('highlight').checked, gFindBar.getElement('find-case-sensitive').checked)) { gFireIE.updateFindBarUI(gFindBar); return; }");
+    hookCodeHead("gFindBar.toggleHighlight", function()
+    {
+      if (gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value,
+                                gFindBar.getElement('highlight').checked,
+                                gFindBar.getElement('find-case-sensitive').checked))
+      {
+        gFireIE.updateFindBarUI(gFindBar);
+        return shouldReturn();
+      }
+    });
 
     // do not return in order to let findbar set the case sensitivity pref
     hookAttr(gFindBar.getElement("find-case-sensitive"), "oncommand", "if (gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value, gFindBar.getElement('highlight').checked, gFindBar.getElement('find-case-sensitive').checked)) { gFireIE.updateFindBarUI(gFindBar); }");
 
-    hookCode("gFindBar._find", /{/, "$& { let gFireIE_value = arguments[0] || gFindBar.getElement('findbar-textbox').value; if (gFireIE.setFindParams(gFireIE_value, gFindBar.getElement('highlight').checked, gFindBar.getElement('find-case-sensitive').checked) && gFireIE.findText(gFireIE_value)) { gFireIE.updateFindBarUI(gFindBar); return; }; }");
+    hookCodeHead("gFindBar._find", function()
+    {
+      let value = arguments[0] || gFindBar.getElement('findbar-textbox').value;
+      if (gFireIE.setFindParams(value, gFindBar.getElement('highlight').checked,
+                                gFindBar.getElement('find-case-sensitive').checked)
+        && gFireIE.findText(value))
+      {
+        gFireIE.updateFindBarUI(gFindBar);
+        return shouldReturn();
+      }
+    });
 
     // disabled, in order to support F3 findNext/Prev
     //hookCode("gFindBar.close", /{/, "$& if (!this.hidden) gFireIE.endFindText();");
 
-    hookAttr("cmd_find", "oncommand", "gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value, gFindBar.getElement('highlight').checked, gFindBar.getElement('find-case-sensitive').checked); gFireIE.resetFindBarUI(gFindBar);", true);
+    hookAttrTail("cmd_find", "oncommand", "gFireIE.setFindParams(gFindBar.getElement('findbar-textbox').value, gFindBar.getElement('highlight').checked, gFindBar.getElement('find-case-sensitive').checked); gFireIE.resetFindBarUI(gFindBar);");
 
-    hookCode("gFindBar._getInitialSelection", /{/, "$& { let gFireIE_value = gFireIE.getSelectionText(this._selectionMaxLen); if (gFireIE_value != null) return gFireIE_value; }");
+    hookCodeHead("gFindBar._getInitialSelection", function()
+    {
+      let value = gFireIE.getSelectionText(this._selectionMaxLen);
+      if (value != null) return shouldReturn(value);
+    });
 
     try
     {
       gFindBar.getElement("findbar-textbox").addEventListener('keypress', function(event)
       {
-          var shouldHandle = !event.altKey && !event.ctrlKey &&
-                             !event.metaKey && !event.shiftKey;
-
-          switch (event.keyCode) {
-            case KeyEvent.DOM_VK_PAGE_UP:
-              if (shouldHandle) {
-                gFireIE.goDoCommand("PageUp");
-              }
-              break;
-            case KeyEvent.DOM_VK_PAGE_DOWN:
-              if (shouldHandle) {
-                gFireIE.goDoCommand("PageDown");
-              }
-              break;
-            case KeyEvent.DOM_VK_UP:
-              gFireIE.goDoCommand("LineUp");
-              break;
-            case KeyEvent.DOM_VK_DOWN:
-              gFireIE.goDoCommand("LineDown");
-              break;
-          }
+        var shouldHandle = !event.altKey && !event.ctrlKey &&
+                           !event.metaKey && !event.shiftKey;
+
+        switch (event.keyCode)
+        {
+          case KeyEvent.DOM_VK_PAGE_UP:
+            if (shouldHandle)
+              gFireIE.goDoCommand("PageUp");
+            break;
+          case KeyEvent.DOM_VK_PAGE_DOWN:
+            if (shouldHandle)
+              gFireIE.goDoCommand("PageDown");
+            break;
+          case KeyEvent.DOM_VK_UP:
+            gFireIE.goDoCommand("LineUp");
+            break;
+          case KeyEvent.DOM_VK_DOWN:
+            gFireIE.goDoCommand("LineDown");
+            break;
+        }
       });
     }
     catch (ex)
@@ -148,8 +285,13 @@ var gFireIE = null;
     {
       Utils.LOG("Fire Gestures detected.");
       GesturePrefObserver.setGestureExtension("FireGestures");
-      hookCode("FireGestures._performAction", /{/, "$& if (gFireIE.goDoFGCommand(arguments[1])) return;");
-      hookCode("FireGestures.getSelectedText", /{/, "$& { let gFireIE_value = gFireIE.getSelectionText(1000, true); if (gFireIE_value != null) return gFireIE_value; }"); // make firegestures' selection based functions work
+      hookCodeHead("FireGestures._performAction", function() { if (gFireIE.goDoFGCommand(arguments[1])) return shouldReturn(); });
+      // make firegestures' selection based functions work
+      hookCodeHead("FireGestures.getSelectedText", function()
+      {
+        let value = gFireIE.getSelectionText(1000, true);
+        if (value != null) return shouldReturn(value);
+      });
     }
   }
 
@@ -163,7 +305,7 @@ var gFireIE = null;
       function hookMGRFunction(name)
       {
         if (mgGestureFunctions[name])
-          hookCode("mgGestureFunctions." + name, /{/, "$& if (gFireIE.goDoMGRCommand('" + name + "')) return;");
+          hookCodeHead("mgGestureFunctions." + name, function() { if (gFireIE.goDoMGRCommand(name)) return shouldReturn(); });
       }
       let functionList = ['mgW_ScrollDown', 'mgW_ScrollUp', 'mgW_ScrollLeft', 'mgW_ScrollRight'];
       for (let i = 0; i < functionList.length; i++)
@@ -183,7 +325,7 @@ var gFireIE = null;
       function hookAiOGFunction(name, action)
       {
         if (typeof(eval(name)) == "function")
-          hookCode(name, /{/, "$& if (gFireIE.goDoAiOGCommand('" + action + "', arguments)) return;");
+          hookCodeHead(name, function() { if (gFireIE.goDoAiOGCommand(action, arguments)) return shouldReturn(); });
       }
       let functionList = [["aioVScrollDocument", "vscroll"]];
       for (let i = 0; i < functionList.length; i++)
@@ -213,10 +355,122 @@ var gFireIE = null;
       Utils.ERROR("Failed to hook function: " + orgFunc);
     }
   }
+  
+  function wrapFunctionHead(orgFunc, myFunc)
+  {
+    return function()
+    {
+      let ret = myFunc.apply(this, arguments);
+      if (ret && ret.shouldReturn)
+        return ret.value;
+      let newArguments = (ret && ret.arguments) || arguments;
+      return orgFunc.apply(this, newArguments);
+    };
+  }
+  
+  function shouldReturn(value)
+  {
+    return { shouldReturn: true, value: value };
+  }
+  
+  function modifyArguments(arguments)
+  {
+    return { shouldReturn: false, arguments: arguments };
+  }
+  
+  function wrapFunctionTail(orgFunc, myFunc)
+  {
+    return function()
+    {
+      let ret = orgFunc.apply(this, arguments);
+      Array.prototype.splice.call(arguments, 0, 0, ret)
+      let myRet = myFunc.apply(this, arguments);
+      return (myRet && myRet.shouldModify) ? myRet.value : ret;
+    };
+  }
+  
+  function wrapFunctionHeadTail(orgFunc, myFuncHead, myFuncTail)
+  {
+    return function()
+    {
+      let ret = myFuncHead.apply(this, arguments);
+      if (ret && ret.shouldReturn)
+        return ret.value;
+      let newArguments = (ret && ret.arguments) || arguments;
+      let orgRet = orgFunc.apply(this, newArguments);
+      Array.prototype.splice.call(newArguments, 0, 0, orgRet)
+      let myRet = myFuncTail.apply(this, newArguments);
+      return (myRet && myRet.shouldModify) ? myRet.value : orgRet;
+    };
+  }
+  
+  function modifyValue(value)
+  {
+    return { shouldModify: true, value: value };
+  }
+  
+  // The safer way: hook code while preserving original function's closures
+  function hookCodeHead(orgFuncName/* String */, myFunc/* Function */)
+  {
+    try
+    {
+      let orgFunc = eval(orgFuncName);
+      if (typeof(orgFunc) == "function")
+      {
+        let wrappedFunc = wrapFunctionHead(orgFunc, myFunc);
+        // execute the assignment
+        if (wrappedFunc !== eval(orgFuncName + "=wrappedFunc"))
+          throw orgFuncName;
+      }
+      else throw orgFuncName;
+    }
+    catch (e)
+    {
+      Utils.ERROR("Failed to hookhead function: " + orgFuncName);
+    }
+  }
 
+  function hookCodeTail(orgFuncName/* String */, myFunc/* Function */)
+  {
+    try
+    {
+      let orgFunc = eval(orgFuncName);
+      if (typeof(orgFunc) == "function")
+      {
+        let wrappedFunc = wrapFunctionTail(orgFunc, myFunc);
+        // execute the assignment
+        if (wrappedFunc !== eval(orgFuncName + "=wrappedFunc"))
+          throw orgFuncName;
+      }
+      else throw orgFuncName;
+    }
+    catch (e)
+    {
+      Utils.ERROR("Failed to hooktail function: " + orgFuncName);
+    }
+  }
+  
+  function hookCodeHeadTail(orgFuncName/* String */, myFuncHead/* Function */, myFuncTail/* Function */)
+  {
+    try
+    {
+      let orgFunc = eval(orgFuncName);
+      if (typeof(orgFunc) == "function")
+      {
+        let wrappedFunc = wrapFunctionHeadTail(orgFunc, myFuncHead, myFuncTail);
+        // execute the assignment
+        if (wrappedFunc !== eval(orgFuncName + "=wrappedFunc"))
+          throw orgFuncName;
+      }
+      else throw orgFuncName;
+    }
+    catch (e)
+    {
+      Utils.ERROR("Failed to hookheadtail function: " + orgFuncName);
+    }
+  }
 
   /** Replace attribute's value V with (myFunc + V) (or (V + myFunc) if insertAtEnd is set to true) */
-
   function hookAttr(parentNode, attrName, myFunc, insertAtEnd)
   {
     if (typeof(parentNode) == "string") parentNode = document.getElementById(parentNode);
@@ -231,39 +485,51 @@ var gFireIE = null;
       Utils.ERROR("Failed to hook attribute: " + attrName);
     }
   }
+  function hookAttrTail(parentNode, attrName, myFunc)
+  {
+    hookAttr(parentNode, attrName, myFunc, true);
+  }
 
   /** Add some code at the beginning of Property's getter and setter */
 
   function hookProp(parentNode, propName, myGetter, mySetter)
   {
+    // must set both getter and setter or the other will be missing
     let oGetter = parentNode.__lookupGetter__(propName);
     let oSetter = parentNode.__lookupSetter__(propName);
-    if (oGetter && myGetter) myGetter = oGetter.toString().replace(/{/, "{" + myGetter.toString().replace(/^.*{/, "").replace(/.*}$/, ""));
-    if (oSetter && mySetter) mySetter = oSetter.toString().replace(/{/, "{" + mySetter.toString().replace(/^.*{/, "").replace(/.*}$/, ""));
-    if (!myGetter) myGetter = oGetter;
-    if (!mySetter) mySetter = oSetter;
-    if (myGetter)
+    if (oGetter && myGetter)
     {
+      let newGetter = wrapFunctionHead(oGetter, myGetter);
       try
       {
-        eval('parentNode.__defineGetter__(propName, ' + myGetter.toString() + ');');
+        parentNode.__defineGetter__(propName, newGetter);
       }
       catch (e)
       {
         Utils.ERROR("Failed to hook property Getter: " + propName);
       }
     }
-    if (mySetter)
+    else if (oGetter)
     {
+      parentNode.__defineGetter__(propName, oGetter);
+    }
+    if (oSetter && mySetter)
+    {
+      let newSetter = wrapFunctionHead(oSetter, mySetter);
       try
       {
-        eval('parentNode.__defineSetter__(propName, ' + mySetter.toString() + ');');
+        parentNode.__defineSetter__(propName, newSetter);
       }
       catch (e)
       {
         Utils.ERROR("Failed to hook property Setter: " + propName);
       }
     }
+    else if (oSetter)
+    {
+      parentNode.__defineSetter__(propName, oSetter);
+    }
+    return { getter: oGetter, setter: oSetter };
   }
 
   gFireIE.hookBrowserGetter = function(aBrowser)
@@ -273,7 +539,12 @@ var gFireIE = null;
     hookProp(aBrowser, "currentURI", function()
     {
       let uri = gFireIE.getURI(this);
-      if (uri) return uri;
+      if (uri)
+      {
+        if (this.FireIE_bUseRealURI)
+          uri = makeURI(Utils.fromContainerUrl(uri.spec));
+        return shouldReturn(uri);
+      }
     });
     // hook aBrowser.sessionHistory
     hookProp(aBrowser, "sessionHistory", function()
@@ -311,14 +582,16 @@ var gFireIE = null;
       if (isIEEngine)
       {
         arguments[0] = Utils.fromContainerUrl(arguments[0]);
+        return modifyArguments(arguments);
       }
     });
   }
-
-  window.addEventListener("load", function()
+  
+  let loadListener = function()
   {
-    window.removeEventListener("load", arguments.callee, false);
+    window.removeEventListener("load", loadListener, false);
     gFireIE.init();
     initializeHooks();
-  }, false);
+  }
+  window.addEventListener("load", loadListener, false);
 })();
diff --git a/extension/defaults/preferences/fireie.js b/extension/defaults/preferences/fireie.js
index af1ee07..c8126ac 100644
--- a/extension/defaults/preferences/fireie.js
+++ b/extension/defaults/preferences/fireie.js
@@ -3,6 +3,7 @@ pref("dom.ipc.plugins.enabled.npfireie64.dll", false);
 pref("extensions.fireie.privatebrowsingwarning", true);
 
 pref("extensions.fireie.currentVersion", "0.0.9");
+pref("extensions.fireie.subscriptions_defaultAdded", false);
 pref("extensions.fireie.subscriptions_autoupdate", true);
 pref("extensions.fireie.subscriptions_listurl", "http://fireie.org/sites/rules/subscriptions.xml");
 pref("extensions.fireie.subscriptions_fallbackurl", "https://fireie.org/getSubscription?version=%VERSION%&url=%SUBSCRIPTION%&downloadURL=%URL%&error=%ERROR%&channelStatus=%CHANNELSTATUS%&responseStatus=%RESPONSESTATUS%");
diff --git a/extension/install.rdf b/extension/install.rdf
index 071e64a..5588251 100644
--- a/extension/install.rdf
+++ b/extension/install.rdf
@@ -5,7 +5,7 @@
 
    <em:id>fireie@fireie.org</em:id>
    <em:name>Fire IE</em:name>
-   <em:version>0.2.5</em:version>
+   <em:version>0.2.6</em:version>
    <em:description>Switch to IE engine in one click and give up your Internet Explorer.</em:description>
    <em:creator>Yuan Xulei</em:creator>
    <em:contributor>Wei Deng</em:contributor>
diff --git a/extension/modules/AppIntegration.jsm b/extension/modules/AppIntegration.jsm
index 28a761b..2285b64 100644
--- a/extension/modules/AppIntegration.jsm
+++ b/extension/modules/AppIntegration.jsm
@@ -93,44 +93,48 @@ let AppIntegration = {
   /**
    * Adds an application window to the tracked list.
    */
-  addWindow: function( /**Window*/ window)
+  addWindow: function( /**Window*/ window) /**WindowWrapper*/
   {
     // Execute first-run actions
     // Show subscriptions dialog if the user doesn't have any subscriptions yet
-    if (Prefs.currentVersion != Utils.addonVersion)
+    Utils.fireWithAddonVersion(function(addonVersion)
     {
-      Prefs.currentVersion = Utils.addonVersion;
-
-      if ("nsISessionStore" in Ci)
+      if (Prefs.currentVersion != addonVersion)
       {
-        // Have to wait for session to be restored
-        let observer = {
-          QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
-          observe: function(subject, topic, data)
-          {
-            observerService.removeObserver(observer, "sessionstore-windows-restored");
-            timer.cancel();
-            timer = null;
-            addSubscription();
-          }
-        };
+        Prefs.currentVersion = addonVersion;
 
-        let observerService = Cc["@mozilla.org/observer-service;1"].getService(Ci.nsIObserverService);
-        observerService.addObserver(observer, "sessionstore-windows-restored", false);
-
-        // Just in case, don't wait more than two seconds
-        let timer = Cc['@mozilla.org/timer;1'].createInstance(Ci.nsITimer);
-        timer.init(observer, 2000, Ci.nsITimer.TYPE_ONE_SHOT);
-      }
-      else
-      {
-        addSubscription();
+        if ("nsISessionStore" in Ci)
+        {
+          // Have to wait for session to be restored
+          let observer = {
+            QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
+            observe: function(subject, topic, data)
+            {
+              observerService.removeObserver(observer, "sessionstore-windows-restored");
+              timer.cancel();
+              timer = null;
+              addSubscription();
+            }
+          };
+
+          let observerService = Cc["@mozilla.org/observer-service;1"].getService(Ci.nsIObserverService);
+          observerService.addObserver(observer, "sessionstore-windows-restored", false);
+
+          // Just in case, don't wait more than two seconds
+          let timer = Cc['@mozilla.org/timer;1'].createInstance(Ci.nsITimer);
+          timer.init(observer, 2000, Ci.nsITimer.TYPE_ONE_SHOT);
+        }
+        else
+        {
+          addSubscription();
+        }
       }
-    }
+    });
 
     let wrapper = new WindowWrapper(window);
     wrappers.push(wrapper);
-
+    
+    return wrapper;
   },
 
   /**
@@ -579,7 +583,7 @@ WindowWrapper.prototype = {
 
   /**
    *  Get current navigation URI with current engine.
-   *  It's of the same function with 与WindowWrapper#getURL.
+   *  It's of the same function with WindowWrapper#getURL.
    */
   getURI: function(aBrowser)
   {
@@ -988,17 +992,17 @@ WindowWrapper.prototype = {
       
       if (Prefs.showStatusText)
       {
-        let event = this.window.gBrowser.contentDocument.createEvent("Event");
+        let event = this.window.gBrowser.contentDocument.createEvent("DataContainerEvent");
         event.initEvent("SetStatusText", false, false);
-        event.statusText = pluginObject.StatusText;
+        event.setData("statusText", pluginObject.StatusText);
         statusBar.dispatchEvent(event);
       }
       else if (!statusBar.hidden && !Prefs.showStatusText)
       {
         // event to notify content doc to hide status text
-        let event = this.window.gBrowser.contentDocument.createEvent("Event");
+        let event = this.window.gBrowser.contentDocument.createEvent("DataContainerEvent");
         event.initEvent("SetStatusText", false, false);
-        event.statusText = "";
+        event.setData("statusText", "");
         statusBar.dispatchEvent(event);
       }
     }
@@ -1926,18 +1930,10 @@ function reloadPrefs()
  */
 function addSubscription()
 {
-  // Don't add subscription if the user has a subscription already
-  let needAdd = true;
-  if (RuleStorage.subscriptions.some(function(subscription) subscription instanceof DownloadableSubscription)) needAdd = false;
-
-  // Only add subscription if user has no rules
-  if (needAdd)
-  {
-    let hasRules = RuleStorage.subscriptions.some(function(subscription) subscription.rules.length);
-    if (hasRules) needAdd = false;
-  }
-
+  // Use a one-time pref to determine whether we should add default subscription
+  let needAdd = Prefs.subscriptions_defaultAdded ? false : true;
   if (!needAdd) return;
+  Prefs.subscriptions_defaultAdded = true;
 
   function notifyUser()
   {
diff --git a/extension/modules/ContentPolicy.jsm b/extension/modules/ContentPolicy.jsm
index d49b35d..c9b65c2 100644
--- a/extension/modules/ContentPolicy.jsm
+++ b/extension/modules/ContentPolicy.jsm
@@ -190,23 +190,23 @@ var PolicyPrivate = {
       {
         if (!(subject instanceof Ci.nsIHttpChannel)) return;
 
-        if (Prefs.autoswitch_enabled)
+        let url = subject.URI.spec;
+        let domain = null;
+        let wnd = Utils.getRequestWindow(subject);
+        if (wnd)
         {
-          let url = subject.URI.spec;
-          let domain = null;
-          let wnd = Utils.getRequestWindow(subject);
-          if (wnd)
-          {
-            domain = Utils.getHostname(wnd.location.href);
-          }
+          domain = Utils.getHostname(wnd.location.href);
+        }
 
-          // Changes the UserAgent to that of IE if necessary.
-          if (Policy.checkUserAgentRule(url, domain) && Utils.ieUserAgent)
-          {
-            // Change user agent
-            subject.setRequestHeader("user-agent", Utils.ieUserAgent, false);
-          }
+        // Changes the UserAgent to that of IE if necessary.
+        if (Policy.checkUserAgentRule(url, domain) && Utils.ieUserAgent)
+        {
+          // Change user agent
+          subject.setRequestHeader("user-agent", Utils.ieUserAgent, false);
+        }
 
+        if (Prefs.autoswitch_enabled)
+        {
           // Checks whether we need switch to IE 
           let isWindowURI = subject.loadFlags & Ci.nsIChannel.LOAD_INITIAL_DOCUMENT_URI;
           if (isWindowURI)
diff --git a/extension/modules/RuleStorage.jsm b/extension/modules/RuleStorage.jsm
index c0ac9e3..e1347bf 100644
--- a/extension/modules/RuleStorage.jsm
+++ b/extension/modules/RuleStorage.jsm
@@ -76,7 +76,7 @@ var RuleStorage = {
       {}
     }
 
-    if (!file) Cu.reportError("Fire-IE: Failed to resolve rule file location from extensions.adblockplus.patternsfile preference");
+    if (!file) Cu.reportError("Fire-IE: Failed to resolve rule file location.");
 
     this.__defineGetter__("sourceFile", function() file);
     return this.sourceFile;
@@ -718,4 +718,4 @@ function parseIniFile( /**nsIUnicharLineInputStream*/ stream) /**Array of String
     }
     else if (wantObj === false && val) curObj.push(val.replace(/\\\[/g, "["));
   }
-}
\ No newline at end of file
+}
diff --git a/extension/modules/Utils.jsm b/extension/modules/Utils.jsm
index 08de107..315cc6c 100644
--- a/extension/modules/Utils.jsm
+++ b/extension/modules/Utils.jsm
@@ -20,6 +20,7 @@ Cu.import("resource://gre/modules/AddonManager.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
 let _addonVersion = null;
+let _addonVersionCallbacks = [];
 
 /**
  * Provides a bunch of utility functions.
@@ -748,6 +749,14 @@ var Utils = {
       }
     }
     return selectedItem;
+  },
+  // runs the callback function after the addon version is obtained
+  fireWithAddonVersion: function(callback)
+  {
+    if (_addonVersion != null)
+      callback(_addonVersion);
+    else
+      _addonVersionCallbacks.push(callback);
   }
 };
 
@@ -770,6 +779,11 @@ var Utils = {
 AddonManager.getAddonByID(Utils.addonID, function(addon)
 {
   _addonVersion = addon.version;
+  _addonVersionCallbacks.forEach(function(callback)
+  {
+    callback(_addonVersion);
+  });
+  _addonVersionCallbacks = null;
 });
 
 (function() {
diff --git a/plugin/BrowserHook/WindowMessageHook.cpp b/plugin/BrowserHook/WindowMessageHook.cpp
index b04aff4..f249ea5 100644
--- a/plugin/BrowserHook/WindowMessageHook.cpp
+++ b/plugin/BrowserHook/WindowMessageHook.cpp
@@ -285,6 +285,10 @@ Exit:
 			case 'Y': // Ctrl+Y, redo 
 			case VK_HOME: // Ctrl+HOME, Scroll to Top
 			case VK_END:  // Ctrl+END, Scroll to end
+			case VK_LEFT: // Ctrl+L/R, Jump to prev/next word
+			case VK_RIGHT:
+			case VK_UP: // Ctrl+U/D, identical to Up/Down
+			case VK_DOWN:
 				return FALSE;
 			default:
 				return TRUE;
diff --git a/plugin/IEHostWindow.cpp b/plugin/IEHostWindow.cpp
index 915888b..441f992 100644
--- a/plugin/IEHostWindow.cpp
+++ b/plugin/IEHostWindow.cpp
@@ -602,8 +602,7 @@ void CIEHostWindow::Zoom(double level)
 	// >= IE7
 	try
 	{
-		if (m_ie.GetSafeHwnd() && 
-			(m_ie.QueryStatusWB(OLECMDID_OPTICAL_ZOOM) & OLECMDF_ENABLED))
+		if (m_ie.GetSafeHwnd())
 		{
 			m_ie.ExecWB(OLECMDID_OPTICAL_ZOOM, OLECMDEXECOPT_DONTPROMPTUSER, &vZoomLevel, NULL);
 		}
@@ -686,6 +685,45 @@ void CIEHostWindow::ScrollHorizontal(bool left)
 	SendKey(left ? VK_LEFT : VK_RIGHT);
 }
 
+BOOL CALLBACK CIEHostWindow::GetInternetExplorerServerCallback(HWND hWnd, LPARAM lParam)
+{
+	CString strClassName;
+	GetClassName(hWnd, strClassName.GetBuffer(MAX_PATH), MAX_PATH);
+	strClassName.ReleaseBuffer(); 
+	if (strClassName == _T("Internet Explorer_Server"))
+	{
+		*(HWND*)lParam = hWnd;
+		return FALSE;
+	}
+	return TRUE;
+}
+
+HWND CIEHostWindow::GetInternetExplorerServer() const
+{
+	HWND parent = this->m_hWnd;
+	HWND hWnd = NULL;
+	EnumChildWindows(parent, GetInternetExplorerServerCallback, (LPARAM)&hWnd);
+	return hWnd;
+}
+
+void CIEHostWindow::ScrollWheelLine(bool up)
+{
+	POINT ptCursorPos;
+	GetCursorPos(&ptCursorPos);
+
+	HWND hWnd = GetInternetExplorerServer();
+	if (hWnd)
+	{
+		TRACE(_T("Found Internet Explorer_Server, scrolling...\n"));
+		::SendMessage(hWnd, WM_MOUSEWHEEL,
+			MAKEWPARAM(0, up ? WHEEL_DELTA : -WHEEL_DELTA), MAKELPARAM(ptCursorPos.x, ptCursorPos.y));
+	}
+	else
+	{
+		TRACE(_T("Internet Explorer_Server not found, scroll canceled.\n"));
+	}
+}
+
 CString CIEHostWindow::GetURL()
 {
 	CString url;
diff --git a/plugin/IEHostWindow.h b/plugin/IEHostWindow.h
index 9c8b5c5..320a014 100644
--- a/plugin/IEHostWindow.h
+++ b/plugin/IEHostWindow.h
@@ -91,6 +91,9 @@ public:
 	 * @return The IE control's UserAgent. It will be ready when the page completes loading for the first time. Before that, empty string will be returned.
 	 */
 	static CString GetIEUserAgentString() {return s_strIEUserAgent;}
+
+	/* Get the embedded Internet Explorer_server window */
+	HWND GetInternetExplorerServer() const;
 		
 public:
 	
@@ -187,6 +190,8 @@ protected:
 	static bool FBCheckRangeVisible(const CComPtr<IHTMLTxtRange>& pRange);
 	static bool FBRangesEqual(const CComPtr<IHTMLTxtRange>& pRange1, const CComPtr<IHTMLTxtRange>& pRange2);
 	static bool FBCheckRangeHighlightable(const CComPtr<IDisplayServices> pDS, const CComPtr<IMarkupServices> pMS, const CComPtr<IHTMLTxtRange>& pRange);
+
+	static BOOL CALLBACK GetInternetExplorerServerCallback(HWND hWnd, LPARAM lParam);
 public:
 	CIECtrl m_ie;
 
@@ -216,6 +221,7 @@ public:
 	void ScrollLine(bool up);
 	void ScrollWhole(bool up);
 	void ScrollHorizontal(bool left);
+	void ScrollWheelLine(bool up);
 
 	// FindBar methods
 	void FBFindText(const CString& text);
diff --git a/plugin/Plugin/ScriptablePluginObject.cpp b/plugin/Plugin/ScriptablePluginObject.cpp
index 33618a7..0ce6230 100644
--- a/plugin/Plugin/ScriptablePluginObject.cpp
+++ b/plugin/Plugin/ScriptablePluginObject.cpp
@@ -409,6 +409,18 @@ namespace Plugin
 			pMainWindow->ScrollHorizontal(false);
 			return true;
 		}
+		else if (name == NPI_ID(ScrollWheelUp))
+		{
+			TRACE ("ScrollWheelUp called!\n");
+			pMainWindow->ScrollWheelLine(true);
+			return true;
+		}
+		else if (name == NPI_ID(ScrollWheelDown))
+		{
+			TRACE ("ScrollWheelDown called!\n");
+			pMainWindow->ScrollWheelLine(false);
+			return true;
+		}
 		else if (name == NPI_ID(FBFindText))
 		{
 			TRACE ("FBFindText called!\n");
diff --git a/plugin/Plugin/ScriptablePluginObject.h b/plugin/Plugin/ScriptablePluginObject.h
index 7594a7b..aff966b 100644
--- a/plugin/Plugin/ScriptablePluginObject.h
+++ b/plugin/Plugin/ScriptablePluginObject.h
@@ -64,6 +64,8 @@ namespace Plugin
 		NPI_DEF(ScrollBottom);
 		NPI_DEF(ScrollLeft);
 		NPI_DEF(ScrollRight);
+		NPI_DEF(ScrollWheelUp);
+		NPI_DEF(ScrollWheelDown);
 
 		// findbar methods
 		NPI_DEF(FBFindText); // FB stands for firefox FindBar
@@ -132,6 +134,8 @@ namespace Plugin
 			NPN_GSI_M(ScrollBottom);
 			NPN_GSI_M(ScrollLeft);
 			NPN_GSI_M(ScrollRight);
+			NPN_GSI_M(ScrollWheelUp);
+			NPN_GSI_M(ScrollWheelDown);
 			NPN_GSI_M(FBFindText);
 			NPN_GSI_M(FBEndFindText);
 			NPN_GSI_M(FBFindAgain);
